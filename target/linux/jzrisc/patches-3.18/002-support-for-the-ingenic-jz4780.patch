diff -urN a/arch/mips/include/asm/mach-jz4780/cpu-feature-overrides.h b/arch/mips/include/asm/mach-jz4780/cpu-feature-overrides.h
--- a/arch/mips/include/asm/mach-jz4780/cpu-feature-overrides.h	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/include/asm/mach-jz4780/cpu-feature-overrides.h	2014-11-18 19:53:38.859528250 +0100
@@ -0,0 +1,71 @@
+/*
+ *  Ingenic JZ4780 specific CPU feature overrides
+ *
+ *  Copyright (C) 2014 Paul Burton <paul.burton@imgtec.com>
+ *  Copyright (C) 2014 José Vázquez Fernández <ppvazquezfer@gmail.com>
+ * 
+ *  This file was derived from: include/asm-mips/cpu-features.h
+ *	Copyright (C) 2003, 2004 Ralf Baechle
+ *	Copyright (C) 2004 Maciej W. Rozycki
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file "COPYING" in the main directory of this archive
+ *  for more details.
+ *
+ */
+#ifndef __ASM_MACH_JZ4780_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_JZ4780_CPU_FEATURE_OVERRIDES_H
+
+#define cpu_has_tlb			1
+#define cpu_has_4kex			1
+#define cpu_has_3k_cache		0
+#define cpu_has_4k_cache		1
+#define cpu_has_tx39_cache		0
+#define cpu_has_fpu			1
+#define cpu_has_32fpr			1
+#define cpu_has_counter			0
+#define cpu_has_watch			1
+#define cpu_has_divec			1
+#define cpu_has_vce			0
+
+#define cpu_has_prefetch		1
+#define cpu_has_mcheck			1
+#define cpu_has_ejtag			1
+#define cpu_has_llsc			1
+#define kernel_uses_llsc		1
+
+#define cpu_has_mips16			0
+#define cpu_has_mdmx			0
+#define cpu_has_mips3d			0
+#define cpu_has_smartmips		0
+
+#define cpu_has_mips32r1		1
+#define cpu_has_mips32r2		1
+#define cpu_has_mips64r1		0
+#define cpu_has_mips64r2		0
+
+#define cpu_has_dsp			0
+#define cpu_has_dsp2			0
+#define cpu_has_mipsmt			0
+#define cpu_has_nofpuex			0
+#define cpu_has_eva			0
+#define cpu_has_cpu_has_maar		0
+#define cpu_has_htw			0
+#define cpu_has_rixiex			0
+#define cpu_has_vz			0
+
+/* #define cpu_has_vint			1 */ 
+/* #define cpu_has_veic			1 */
+
+#define cpu_has_64bits			0
+#define cpu_has_64bit_zero_reg		0
+
+#define cpu_dcache_size()       	(32 * 1024)
+#define cpu_dcache_ways()		8
+#define cpu_dcache_line_size()		32
+#define cpu_icache_size()		(32 * 1024)
+#define cpu_icache_ways()		8
+#define cpu_icache_line_size()		32
+#define cpu_scache_line_size()		128
+
+#endif
diff -urN a/arch/mips/include/asm/mach-jz4780/gpio.h b/arch/mips/include/asm/mach-jz4780/gpio.h
--- a/arch/mips/include/asm/mach-jz4780/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/include/asm/mach-jz4780/gpio.h	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,34 @@
+/*
+ * JZ4780 GPIOs
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __MIPS_ASM_MACH_JZ4780_GPIO_H__
+#define __MIPS_ASM_MACH_JZ4780_GPIO_H__
+
+#include <asm-generic/gpio.h>
+
+/* simply use gpiolib */
+#define gpio_get_value  __gpio_get_value
+#define gpio_set_value  __gpio_set_value
+#define gpio_cansleep   __gpio_cansleep
+#define gpio_to_irq	__gpio_to_irq
+
+#endif /* __MIPS_ASM_MACH_JZ4780_GPIO_H__ */
diff -urN a/arch/mips/include/asm/mach-jz4780/irq.h b/arch/mips/include/asm/mach-jz4780/irq.h
--- a/arch/mips/include/asm/mach-jz4780/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/include/asm/mach-jz4780/irq.h	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,30 @@
+/*
+ * JZ4780 IRQ configuration
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __MIPS_ASM_MACH_JZ4780_IRQ_H__
+#define __MIPS_ASM_MACH_JZ4780_IRQ_H__
+
+#define NR_IRQS 256
+
+#include_next <irq.h>
+
+#endif /* __MIPS_ASM_MACH_JZ4780_IRQ_H__ */
diff -urN a/arch/mips/include/asm/mach-jz4780/jz4780-cgu.h b/arch/mips/include/asm/mach-jz4780/jz4780-cgu.h
--- a/arch/mips/include/asm/mach-jz4780/jz4780-cgu.h	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/include/asm/mach-jz4780/jz4780-cgu.h	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,197 @@
+/*
+ * JZ4780 CGU driver
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __MIPS_ASM_MACH_JZ4780_JZ4780_CGU_H__
+#define __MIPS_ASM_MACH_JZ4780_JZ4780_CGU_H__
+
+/* CGU register offsets */
+#define CGU_REG_CLOCKCONTROL	0x00
+#define CGU_REG_PLLCONTROL	0x0c
+#define CGU_REG_APLL		0x10
+#define CGU_REG_MPLL		0x14
+#define CGU_REG_EPLL		0x18
+#define CGU_REG_VPLL		0x1c
+#define CGU_REG_OPCR		0x24
+#define CGU_REG_DDRCDR		0x2c
+#define CGU_REG_VPUCDR		0x30
+#define CGU_REG_USBPCR		0x3c
+#define CGU_REG_USBRDT		0x40
+#define CGU_REG_USBVBFIL	0x44
+#define CGU_REG_USBPCR1		0x48
+#define CGU_REG_LP0CDR		0x54
+#define CGU_REG_I2SCDR		0x60
+#define CGU_REG_LP1CDR		0x64
+#define CGU_REG_MSC0CDR		0x68
+#define CGU_REG_UHCCDR		0x6c
+#define CGU_REG_SSICDR		0x74
+#define CGU_REG_CIMCDR		0x7c
+#define CGU_REG_PCMCDR		0x84
+#define CGU_REG_GPUCDR		0x88
+#define CGU_REG_HDMICDR		0x8c
+#define CGU_REG_MSC1CDR		0xa4
+#define CGU_REG_MSC2CDR		0xa8
+#define CGU_REG_BCHCDR		0xac
+#define CGU_REG_CLOCKSTATUS	0xd4
+
+/* bits within a PLL control register */
+#define PLLCTL_M_SHIFT		19
+#define PLLCTL_M_MASK		(0x1fff << PLLCTL_M_SHIFT)
+#define PLLCTL_N_SHIFT		13
+#define PLLCTL_N_MASK		(0x3f << PLLCTL_N_SHIFT)
+#define PLLCTL_OD_SHIFT		9
+#define PLLCTL_OD_MASK		(0xf << PLLCTL_OD_SHIFT)
+#define PLLCTL_ON		(1 << 4)
+#define PLLCTL_BYPASS		(1 << 1)
+#define PLLCTL_ENABLE		(1 << 0)
+
+/* bits within the OPCR register */
+#define OPCR_SPENDN0		(1 << 7)
+#define OPCR_SPENDN1		(1 << 6)
+
+/* bits within the USBPCR register */
+#define USBPCR_USB_MODE		BIT(31)
+#define USBPCR_IDPULLUP_MASK	(0x3 << 28)
+#define USBPCR_COMMONONN	BIT(25)
+#define USBPCR_VBUSVLDEXT	BIT(24)
+#define USBPCR_VBUSVLDEXTSEL	BIT(23)
+#define USBPCR_POR		BIT(22)
+#define USBPCR_OTG_DISABLE	BIT(20)
+#define USBPCR_COMPDISTUNE_MASK	(0x7 << 17)
+#define USBPCR_OTGTUNE_MASK	(0x7 << 14)
+#define USBPCR_SQRXTUNE_MASK	(0x7 << 11)
+#define USBPCR_TXFSLSTUNE_MASK	(0xf << 7)
+#define USBPCR_TXPREEMPHTUNE	BIT(6)
+#define USBPCR_TXHSXVTUNE_MASK	(0x3 << 4)
+#define USBPCR_TXVREFTUNE_MASK	0xf
+
+/* bits within the USBPCR1 register */
+#define USBPCR1_REFCLKSEL_SHIFT	26
+#define USBPCR1_REFCLKSEL_MASK	(0x3 << USBPCR1_REFCLKSEL_SHIFT)
+#define USBPCR1_REFCLKSEL_CORE	(0x2 << USBPCR1_REFCLKSEL_SHIFT)
+#define USBPCR1_REFCLKDIV_SHIFT	24
+#define USBPCR1_REFCLKDIV_MASK	(0x3 << USBPCR1_REFCLKDIV_SHIFT)
+#define USBPCR1_REFCLKDIV_19_2	(0x3 << USBPCR1_REFCLKDIV_SHIFT)
+#define USBPCR1_REFCLKDIV_48	(0x2 << USBPCR1_REFCLKDIV_SHIFT)
+#define USBPCR1_REFCLKDIV_24	(0x1 << USBPCR1_REFCLKDIV_SHIFT)
+#define USBPCR1_REFCLKDIV_12	(0x0 << USBPCR1_REFCLKDIV_SHIFT)
+#define USBPCR1_USB_SEL		BIT(28)
+#define USBPCR1_WORD_IF0	BIT(19)
+#define USBPCR1_WORD_IF1	BIT(18)
+
+/* bits within the USBRDT register */
+#define USBRDT_VBFIL_LD_EN	BIT(25)
+#define USBRDT_USBRDT_MASK	0x7fffff
+
+/* bits within the USBVBFIL register */
+#define USBVBFIL_IDDIGFIL_SHIFT	16
+#define USBVBFIL_IDDIGFIL_MASK	(0xffff << USBVBFIL_IDDIGFIL_SHIFT)
+#define USBVBFIL_USBVBFIL_MASK	(0xffff)
+
+enum jz4780_usb_port {
+	USB_PORT_OTG	= 0,
+	USB_PORT_HOST	= 1,
+};
+
+enum jz4780_usb_otg_mode {
+	USB_OTG_MODE_MENTOR	= 0,
+	USB_OTG_MODE_SYNOPSYS	= 1,
+};
+
+enum jz4780_usb_utmi_bus_width {
+	USB_PORT_UTMI_BUS_WIDTH_8	= 0,
+	USB_PORT_UTMI_BUS_WIDTH_16	= 1,
+};
+
+/**
+ * jz4780_cgu_set_usb_suspend - (un)suspend a USB port
+ * @port: the USB port whose state should be changed
+ * @suspend: non-zero if the port should be suspended, else zero
+ *
+ * Returns zero on success, else -ERRNO.
+ */
+#ifndef CONFIG_MACH_JZ4780
+static inline int jz4780_cgu_set_usb_suspend(enum jz4780_usb_port port,
+					     bool suspend)
+{
+	BUG();
+}
+#else
+extern int jz4780_cgu_set_usb_suspend(enum jz4780_usb_port port,
+				      bool suspend);
+#endif
+
+/**
+ * jz4780_cgu_set_usb_otg_mode - Set OTG Mode
+ * @mode: the USB mode to be configured.
+ *
+ * Returns zero on success, else -ERRNO.
+ */
+extern int jz4780_cgu_set_usb_otg_mode(enum jz4780_usb_otg_mode mode);
+
+/**
+ * jz4780_cgu_set_usb_port_utmi_bus_width - Set the USB port bus width
+ * @port: the USB port whose width should be changed
+ * @width: the bus width to set the USB port to
+ *
+ * Returns zero on success, else -ERRNO.
+ */
+extern int jz4780_cgu_set_usb_utmi_bus_width(enum jz4780_usb_port port,
+					enum jz4780_usb_utmi_bus_width width);
+
+/**
+ * jz4780_cgu_set_usb_usbvbfil - Set the USB VBUS jitter filter time
+ * @value: the value to set the VBUS jitter filter time to
+ */
+extern void jz4780_cgu_set_usb_usbvbfil(u32 value);
+
+/**
+ * jz4780_cgu_set_usb_iddigfil - Set the USB iddig jitter filter time
+ * @value: the value to set the iddig jitter filter time to
+ */
+extern void jz4780_cgu_set_usb_iddigfil(u32 value);
+
+/**
+ * jz4780_cgu_set_usb_usbrdt - Set the USB reset detect time
+ * @value: the value to set the reset detect time to
+ */
+extern void jz4780_cgu_set_usb_usbrdt(u32 value);
+
+/**
+ * jz4780_cgu_set_usb_vbfil_ld_en - Enable the VBUS filter data load enable
+ * @value: the value to set the reset detect time to
+ */
+extern void jz4780_cgu_set_usb_vbfil_ld_en(bool enable);
+
+/**
+ * jz4780_cgu_usb_reset - Resets the USB module.
+ */
+extern void jz4780_cgu_usb_reset(void);
+
+/**
+ * jz4780_cgu_set_usbpcr_param - Sets the parameters of USBPCR reg
+ * @param: the parameter to change
+ * @value: the value to set it to
+ * Returns zero on success, else -ERRNO.
+ */
+extern int jz4780_cgu_set_usbpcr_param(u32 param, bool enable);
+
+#endif /* __MIPS_ASM_MACH_JZ4780_JZ4780_CGU_H__ */
diff -urN a/arch/mips/include/asm/mach-jz4780/jz4780.h b/arch/mips/include/asm/mach-jz4780/jz4780.h
--- a/arch/mips/include/asm/mach-jz4780/jz4780.h	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/include/asm/mach-jz4780/jz4780.h	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,37 @@
+/*
+ * JZ4780 SoC definitions
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __MIPS_ASM_MACH_JZ4780_JZ4780_H__
+#define __MIPS_ASM_MACH_JZ4780_JZ4780_H__
+
+/* APB bus devices */
+#define JZ4780_CPM_BASE		0xb0000000
+#define JZ4780_TCU_BASE		0xb0002000
+#define JZ4780_RTC_BASE		0xb0003000
+#define JZ4780_GPIO_BASE	0xb0010000
+#define JZ4780_UART0_BASE	0xb0030000
+#define JZ4780_UART1_BASE	0xb0031000
+#define JZ4780_UART2_BASE	0xb0032000
+#define JZ4780_UART3_BASE	0xb0033000
+#define JZ4780_UARTn_BASE(n)	(JZ4780_UART0_BASE + (n * 0x1000))
+
+#endif /* __MIPS_ASM_MACH_JZ4780_JZ4780_H__ */
diff -urN a/arch/mips/include/asm/mach-jz4780/jz4780-smp.h b/arch/mips/include/asm/mach-jz4780/jz4780-smp.h
--- a/arch/mips/include/asm/mach-jz4780/jz4780-smp.h	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/include/asm/mach-jz4780/jz4780-smp.h	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,99 @@
+/*
+ * JZ4780 SMP
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __MIPS_ASM_MACH_JZ4780_JZ4780_SMP_H__
+#define __MIPS_ASM_MACH_JZ4780_JZ4780_SMP_H__
+
+#define read_c0_corectrl()		__read_32bit_c0_register($12, 2)
+#define write_c0_corectrl(val)		__write_32bit_c0_register($12, 2, val)
+
+#define read_c0_corestatus()		__read_32bit_c0_register($12, 3)
+#define write_c0_corestatus(val)	__write_32bit_c0_register($12, 3, val)
+
+#define read_c0_reim()			__read_32bit_c0_register($12, 4)
+#define write_c0_reim(val)		__write_32bit_c0_register($12, 4, val)
+
+#define read_c0_mailbox0()		__read_32bit_c0_register($20, 0)
+#define write_c0_mailbox0(val)		__write_32bit_c0_register($20, 0, val)
+
+#define read_c0_mailbox1()		__read_32bit_c0_register($20, 1)
+#define write_c0_mailbox1(val)		__write_32bit_c0_register($20, 1, val)
+
+/*
+ * Core Control register
+ */
+#define CORECTRL_SLEEP1M_SHIFT	17
+#define CORECTRL_SLEEP1M	(_ULCAST_(0x1) << CORECTRL_SLEEP1M_SHIFT)
+#define CORECTRL_SLEEP0M_SHIFT	16
+#define CORECTRL_SLEEP0M	(_ULCAST_(0x1) << CORECTRL_SLEEP0M_SHIFT)
+#define CORECTRL_RPC1_SHIFT	9
+#define CORECTRL_RPC1		(_ULCAST_(0x1) << CORECTRL_RPC1_SHIFT)
+#define CORECTRL_RPC0_SHIFT	8
+#define CORECTRL_RPC0		(_ULCAST_(0x1) << CORECTRL_RPC0_SHIFT)
+#define CORECTRL_SWRST1_SHIFT	1
+#define CORECTRL_SWRST1		(_ULCAST_(0x1) << CORECTRL_SWRST1_SHIFT)
+#define CORECTRL_SWRST0_SHIFT	0
+#define CORECTRL_SWRST0		(_ULCAST_(0x1) << CORECTRL_SWRST0_SHIFT)
+
+/*
+ * Core Status register
+ */
+#define CORESTATUS_SLEEP1_SHIFT	17
+#define CORESTATUS_SLEEP1	(_ULCAST_(0x1) << CORESTATUS_SLEEP1_SHIFT)
+#define CORESTATUS_SLEEP0_SHIFT	16
+#define CORESTATUS_SLEEP0	(_ULCAST_(0x1) << CORESTATUS_SLEEP0_SHIFT)
+#define CORESTATUS_IRQ1P_SHIFT	9
+#define CORESTATUS_IRQ1P	(_ULCAST_(0x1) << CORESTATUS_IRQ1P_SHIFT)
+#define CORESTATUS_IRQ0P_SHIFT	8
+#define CORESTATUS_IRQ0P	(_ULCAST_(0x1) << CORESTATUS_IRQ8P_SHIFT)
+#define CORESTATUS_MIRQ1P_SHIFT	1
+#define CORESTATUS_MIRQ1P	(_ULCAST_(0x1) << CORESTATUS_MIRQ1P_SHIFT)
+#define CORESTATUS_MIRQ0P_SHIFT	0
+#define CORESTATUS_MIRQ0P	(_ULCAST_(0x1) << CORESTATUS_MIRQ0P_SHIFT)
+
+/*
+ * Reset Entry & IRQ Mask register
+ */
+#define REIM_ENTRY_SHIFT	16
+#define REIM_ENTRY		(_ULCAST_(0xffff) << REIM_ENTRY_SHIFT)
+#define REIM_IRQ1M_SHIFT	9
+#define REIM_IRQ1M		(_ULCAST_(0x1) << REIM_IRQ1M_SHIFT)
+#define REIM_IRQ0M_SHIFT	8
+#define REIM_IRQ0M		(_ULCAST_(0x1) << REIM_IRQ0M_SHIFT)
+#define REIM_MBOXIRQ1M_SHIFT	1
+#define REIM_MBOXIRQ1M		(_ULCAST_(0x1) << REIM_MBOXIRQ1M_SHIFT)
+#define REIM_MBOXIRQ0M_SHIFT	0
+#define REIM_MBOXIRQ0M		(_ULCAST_(0x1) << REIM_MBOXIRQ0M_SHIFT)
+
+#ifdef CONFIG_SMP
+
+extern void jz4780_smp_init(void);
+extern void jz4780_secondary_cpu_entry(void);
+extern void jz4780_smp_irq(void);
+
+#else /* !CONFIG_SMP */
+
+static inline void jz4780_smp_init(void) { }
+
+#endif /* !CONFIG_SMP */
+
+#endif /* __MIPS_ASM_MACH_JZ4780_JZ4780_SMP_H__ */
diff -urN a/arch/mips/include/asm/mach-jz4780/war.h b/arch/mips/include/asm/mach-jz4780/war.h
--- a/arch/mips/include/asm/mach-jz4780/war.h	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/include/asm/mach-jz4780/war.h	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,39 @@
+/*
+ * JZ4780 workarounds
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __MIPS_ASM_MACH_JZ4780_WAR_H__
+#define __MIPS_ASM_MACH_JZ4780_WAR_H__
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __MIPS_ASM_MACH_JZ4780_WAR_H__ */
diff -urN a/arch/mips/jz4780/early_uart.c b/arch/mips/jz4780/early_uart.c
--- a/arch/mips/jz4780/early_uart.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/jz4780/early_uart.c	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,73 @@
+/*
+ * JZ4780 early UART access
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/io.h>
+#include <jz4780.h>
+
+static uintptr_t early_uart_base;
+
+#define JZ4780_CPM_CLKGR0	0x20
+#define JZ4780_CPM_CLKGR0_UART0_BIT 15
+
+static void detect_early_uart(void)
+{
+	uint32_t clkgr0;
+	int i;
+
+	clkgr0 = readl((void *)(JZ4780_CPM_BASE + JZ4780_CPM_CLKGR0));
+
+	for (i = 0; i < 4; i++) {
+		/* skip UARTs with gated clocks */
+		if (clkgr0 & (1 << (JZ4780_CPM_CLKGR0_UART0_BIT + i)))
+			continue;
+
+		/*
+		 * use this UART - note we assume that if the bootloader ungated
+		 * the clock then it also initialized the UART to a sane
+		 * configuration.
+		 */
+		early_uart_base = JZ4780_UARTn_BASE(i);
+		return;
+	}
+
+	/* no UART is available */
+	early_uart_base = (uintptr_t)~0;
+}
+
+int prom_putchar(char c)
+{
+	void __iomem *thr, __iomem *lsr;
+
+	if (!early_uart_base)
+		detect_early_uart();
+
+	if (early_uart_base == (uintptr_t)~0)
+		return -1;
+
+	thr = (void __iomem *)(early_uart_base + 0x00);
+	lsr = (void __iomem *)(early_uart_base + 0x14);
+
+	while ((readb(lsr) & 0x60) != 0x60)
+		;
+	writeb(c, thr);
+	return 1;
+}
diff -urN a/arch/mips/jz4780/irq.c b/arch/mips/jz4780/irq.c
--- a/arch/mips/jz4780/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/jz4780/irq.c	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,55 @@
+/*
+ * JZ4780 IRQ handling
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/irqchip.h>
+#include <linux/linkage.h>
+#include <asm/irq.h>
+#include <asm/irq_cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/mach-jz4780/jz4780-smp.h>
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	uint32_t pending = read_c0_cause() & read_c0_status() & CAUSEF_IP;
+
+	if (pending & CAUSEF_IP4) {
+		/* from OS timer */
+		do_IRQ(4);
+#ifdef CONFIG_SMP
+	} else if (pending & CAUSEF_IP3) {
+		/* from a mailbox write */
+		do_IRQ(3);
+#endif
+	} else if (pending & CAUSEF_IP2) {
+		/* from interrupt controller */
+		do_IRQ(2);
+	} else {
+		spurious_interrupt();
+	}
+}
+
+void __init arch_init_irq(void)
+{
+	mips_cpu_irq_init();
+	irqchip_init();
+}
diff -urN a/arch/mips/jz4780/Kconfig b/arch/mips/jz4780/Kconfig
--- a/arch/mips/jz4780/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/jz4780/Kconfig	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,9 @@
+choice
+	prompt "Machine type"
+	depends on MACH_JZ4780
+	default JZ4780_CI20
+
+config JZ4780_CI20
+	bool "CI20"
+
+endchoice
diff -urN a/arch/mips/jz4780/Makefile b/arch/mips/jz4780/Makefile
--- a/arch/mips/jz4780/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/jz4780/Makefile	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,31 @@
+#
+# Ingenic JZ4780 makefile
+#
+# Copyright (c) 2013 Imagination Technologies
+# Author: Paul Burton <paul.burton@imgtec.com>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+obj-y += early_uart.o
+obj-y += irq.o
+obj-y += reset.o
+obj-y += setup.o
+
+obj-$(CONFIG_SMP) += smp.o
+obj-$(CONFIG_SMP) += smp-entry.o
+
+obj-y += dts/
diff -urN a/arch/mips/jz4780/Platform b/arch/mips/jz4780/Platform
--- a/arch/mips/jz4780/Platform	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/jz4780/Platform	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,3 @@
+platform-$(CONFIG_MACH_JZ4780)	+= jz4780/
+cflags-$(CONFIG_MACH_JZ4780)	+= -I$(srctree)/arch/mips/include/asm/mach-jz4780
+load-$(CONFIG_MACH_JZ4780)	+= 0xffffffff80000000
diff -urN a/arch/mips/jz4780/reset.c b/arch/mips/jz4780/reset.c
--- a/arch/mips/jz4780/reset.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/jz4780/reset.c	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,157 @@
+/*
+ * JZ4780 poweroff/reset
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Alex Smith <alex.smith@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/io.h>
+#include <linux/pm.h>
+
+#include <asm/reboot.h>
+
+#include <asm/mach-jz4780/jz4780.h>
+
+#define CPM_RSR		0x8
+
+#define RTC_RTCCR	0x0
+#define RTC_HCR		0x20
+#define RTC_HWFCR	0x24
+#define RTC_HRCR	0x28
+#define RTC_HWCR	0x2c
+#define RTC_HWRSR	0x30
+#define RTC_WENR	0x3c
+
+#define RTC_RTCCR_WRDY	BIT(7)
+
+#define RTC_HCR_PD	BIT(0)
+
+#define RTC_HWCR_EPDET	BIT(3)
+
+#define RTC_WENR_PAT	0xa55a
+#define RTC_WENR_WEN	BIT(31)
+
+#define WDT_TDR		0x0
+#define WDT_TCER	0x4
+#define WDT_TCNT	0x8
+#define WDT_TCSR	0xc
+#define TCU_TSCR	0x3c
+
+#define WDT_TCER_RTC_EN	BIT(1)
+
+#define TCU_TSR_WDTS	BIT(16)
+
+#define RTCLK_RATE	32768
+
+static void jz4780_halt(void)
+{
+	local_irq_disable();
+
+	while (1) {
+		__asm__(".set	push\n"
+			".set	mips3\n"
+			"wait\n"
+			".set	pop\n");
+	}
+}
+
+static void jz4780_restart(char *command)
+{
+	void __iomem *cpm_base = (void __iomem *)JZ4780_CPM_BASE;
+	void __iomem *tcu_base = (void __iomem *)JZ4780_TCU_BASE;
+
+	local_irq_disable();
+
+	/* Clear reset status. */
+	writel(0, cpm_base + CPM_RSR);
+
+	/* Disable watchdog timer. */
+	writel(0, tcu_base + WDT_TCER);
+
+	/* Enable clock to WDT. */
+	writel(TCU_TSR_WDTS, tcu_base + TCU_TSCR);
+
+	/* Configure watchdog timer to count up to 4 milliseconds. */
+	writel(0, tcu_base + WDT_TCNT);
+	writel((RTCLK_RATE * 4) / 1000, tcu_base + WDT_TDR);
+	writel(WDT_TCER_RTC_EN, tcu_base + WDT_TCSR);
+
+	/* Enable watchdog timer. */
+	writel(1, tcu_base + WDT_TCER);
+
+	jz4780_halt();
+}
+
+static inline void jz4780_rtc_wait_ready(void)
+{
+	void __iomem *rtccr = (void __iomem *)JZ4780_RTC_BASE + RTC_RTCCR;
+
+	while (!(readl(rtccr) & RTC_RTCCR_WRDY))
+		;
+}
+
+static inline void jz4780_rtc_write_reg(int reg, unsigned long val)
+{
+	void __iomem *wenr = (void __iomem *)JZ4780_RTC_BASE + RTC_WENR;
+	void __iomem *addr = (void __iomem *)JZ4780_RTC_BASE + reg;
+
+	/*
+	 * Ensure that registers are writeable. Doing this once doesn't seem
+	 * to be sufficient, writing certain registers causes us to hang waiting
+	 * for WRDY afterwards unless this is done before each write.
+	 */
+	jz4780_rtc_wait_ready();
+	writel(RTC_WENR_PAT, wenr);
+	jz4780_rtc_wait_ready();
+	while (!(readl(wenr) & RTC_WENR_WEN))
+		;
+
+	jz4780_rtc_wait_ready();
+	writel(val, addr);
+}
+
+static void jz4780_power_off(void)
+{
+	local_irq_disable();
+
+	/* Set minimum wakeup pin assertion time to 1 second. */
+	jz4780_rtc_write_reg(RTC_HWFCR, RTCLK_RATE);
+
+	/* Set reset pin assertion time to 60 ms. */
+	jz4780_rtc_write_reg(RTC_HRCR, (60 * RTCLK_RATE / 1000));
+
+	/* Clear wakeup status register. */
+	jz4780_rtc_write_reg(RTC_HWRSR, 0);
+
+	jz4780_rtc_write_reg(RTC_HWCR, RTC_HWCR_EPDET);
+
+	/* Power down the chip. */
+	jz4780_rtc_write_reg(RTC_HCR, RTC_HCR_PD);
+
+	jz4780_halt();
+}
+
+static int __init jz4780_reset_setup(void)
+{
+	_machine_halt = jz4780_halt;
+	_machine_restart = jz4780_restart;
+	pm_power_off = jz4780_power_off;
+
+	return 0;
+}
+arch_initcall(jz4780_reset_setup);
diff -urN a/arch/mips/jz4780/setup.c b/arch/mips/jz4780/setup.c
--- a/arch/mips/jz4780/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/jz4780/setup.c	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,78 @@
+/*
+ * JZ4780 setup
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/bootmem.h>
+#include <linux/clk-provider.h>
+#include <linux/clocksource.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/of_platform.h>
+
+#include <asm/bootinfo.h>
+#include <asm/fw/fw.h>
+#include <asm/mach-jz4780/jz4780-smp.h>
+#include <asm/prom.h>
+
+//extern struct boot_param_header __dtb_start;
+
+void __init plat_mem_setup(void)
+{
+	__dt_setup_arch(__dtb_start);
+	strlcpy(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
+}
+
+void __init prom_init(void)
+{
+	jz4780_smp_init();
+	fw_init_cmdline();
+}
+
+void prom_free_prom_memory(void)
+{
+}
+
+void __init plat_time_init(void)
+{
+	of_clk_init(NULL);
+	clocksource_of_init();
+}
+
+void __init device_tree_init(void)
+{
+	unflatten_and_copy_device_tree();
+}
+
+const char *get_system_type(void)
+{
+	return "JZ4780 based system";
+}
+
+static struct of_device_id __initdata jz4780_ids[] = {
+	{ .compatible = "simple-bus", },
+	{},
+};
+
+int __init jz4780_publish_devices(void)
+{
+	return of_platform_bus_probe(NULL, jz4780_ids, NULL);
+}
+device_initcall(jz4780_publish_devices);
diff -urN a/arch/mips/jz4780/smp.c b/arch/mips/jz4780/smp.c
--- a/arch/mips/jz4780/smp.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/jz4780/smp.c	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,270 @@
+/*
+ * JZ4780 SMP
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/clk.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <asm/r4kcache.h>
+#include <asm/smp-ops.h>
+#include <asm/mach-jz4780/jz4780-smp.h>
+
+static struct clk *cpu_clock_gates[CONFIG_NR_CPUS] = { NULL };
+
+u32 jz4780_cpu_entry_sp;
+u32 jz4780_cpu_entry_gp;
+
+static DEFINE_SPINLOCK(smp_lock);
+
+static irqreturn_t mbox_handler(int irq, void *dev_id)
+{
+	int cpu = smp_processor_id();
+	u32 action, status;
+
+	spin_lock(&smp_lock);
+
+	switch (cpu) {
+	case 0:
+		action = read_c0_mailbox0();
+		write_c0_mailbox0(0);
+		break;
+	case 1:
+		action = read_c0_mailbox1();
+		write_c0_mailbox1(0);
+		break;
+	default:
+		panic("unhandled cpu %d!", cpu);
+	}
+
+	/* clear pending mailbox interrupt */
+	status = read_c0_corestatus();
+	status &= ~(CORESTATUS_MIRQ0P << cpu);
+	write_c0_corestatus(status);
+
+	spin_unlock(&smp_lock);
+
+	if (action & SMP_RESCHEDULE_YOURSELF)
+		scheduler_ipi();
+	if (action & SMP_CALL_FUNCTION)
+		smp_call_function_interrupt();
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction mbox_action = {
+	.handler = mbox_handler,
+	.name = "core mailbox",
+	.flags = IRQF_PERCPU | IRQF_NO_THREAD,
+};
+
+static void jz4780_smp_setup(void)
+{
+	u32 addr, reim;
+
+	reim = read_c0_reim();
+
+	/* mask mailbox interrupts for this core */
+	reim &= ~REIM_MBOXIRQ0M;
+	write_c0_reim(reim);
+
+	/* clear mailboxes & pending mailbox IRQs */
+	write_c0_mailbox0(0);
+	write_c0_mailbox1(0);
+	write_c0_corestatus(0);
+
+	/* set reset entry point */
+	addr = KSEG1ADDR((u32)&jz4780_secondary_cpu_entry);
+	BUG_ON(addr & ~REIM_ENTRY);
+	reim &= ~REIM_ENTRY;
+	reim |= addr & REIM_ENTRY;
+
+	/* unmask mailbox interrupts for this core */
+	reim |= REIM_MBOXIRQ0M;
+	write_c0_reim(reim);
+	set_c0_status(STATUSF_IP3);
+	irq_enable_hazard();
+}
+
+static void jz4780_smp_prepare_cpus(unsigned int max_cpus)
+{
+	struct device_node *cpu_node;
+	unsigned cpu, ctrl;
+	int err;
+
+	/* setup the mailbox IRQ */
+	setup_irq(MIPS_CPU_IRQ_BASE + 3, &mbox_action);
+
+	init_cpu_present(cpu_possible_mask);
+
+	ctrl = read_c0_corectrl();
+
+	for (cpu = 0; cpu < max_cpus; cpu++) {
+		__cpu_number_map[cpu] = cpu;
+		__cpu_logical_map[cpu] = cpu;
+
+		/* use reset entry point from REIM register */
+		ctrl |= CORECTRL_RPC0 << cpu;
+	}
+
+	for_each_compatible_node(cpu_node, NULL, "ingenic,xburst") {
+		err = of_property_read_u32_index(cpu_node, "reg", 0, &cpu);
+		if (err) {
+			pr_err("Failed to read index of %s\n",
+			       cpu_node->full_name);
+			continue;
+		}
+
+		cpu_clock_gates[cpu] = of_clk_get(cpu_node, 0);
+		if (IS_ERR(cpu_clock_gates[cpu])) {
+			cpu_clock_gates[cpu] = NULL;
+			continue;
+		}
+
+		err = clk_prepare(cpu_clock_gates[cpu]);
+		if (err)
+			pr_err("Failed to prepare CPU clock gate\n");
+	}
+
+	write_c0_corectrl(ctrl);
+}
+
+static void jz4780_boot_secondary(int cpu, struct task_struct *idle)
+{
+	unsigned long flags;
+	u32 ctrl;
+
+	spin_lock_irqsave(&smp_lock, flags);
+
+	/* ensure the core is in reset */
+	ctrl = read_c0_corectrl();
+	ctrl |= CORECTRL_SWRST0 << cpu;
+	write_c0_corectrl(ctrl);
+
+	/* ungate core clock */
+	if (cpu_clock_gates[cpu])
+		clk_enable(cpu_clock_gates[cpu]);
+
+	/* power up the core */
+	/* TODO: write a nice driver/abstraction for this */
+	{
+		void __iomem *lpcr = (void __iomem *)0xb0000004;
+		writel(readl(lpcr) & ~(1 << 31), lpcr);
+		/* wait for the CPU to be powered up */
+		while (readl(lpcr) & (1 << 27))
+			;
+	}
+
+	/* set entry sp/gp register values */
+	jz4780_cpu_entry_sp = __KSTK_TOS(idle);
+	jz4780_cpu_entry_gp = (u32)task_thread_info(idle);
+	smp_wmb();
+
+	/* take the core out of reset */
+	ctrl &= ~(CORECTRL_SWRST0 << cpu);
+	write_c0_corectrl(ctrl);
+
+	spin_unlock_irqrestore(&smp_lock, flags);
+}
+
+static void jz4780_init_secondary(void)
+{
+}
+
+static void jz4780_smp_finish(void)
+{
+	int cpu = smp_processor_id();
+	u32 reim;
+
+	spin_lock(&smp_lock);
+
+	/* unmask mailbox interrupts for this core */
+	reim = read_c0_reim();
+	reim |= REIM_MBOXIRQ0M << smp_processor_id();
+	write_c0_reim(reim);
+
+	spin_unlock(&smp_lock);
+
+	/* unmask interrupts for this core */
+	change_c0_status(ST0_IM, STATUSF_IP3 | STATUSF_IP2 |
+			 STATUSF_IP1 | STATUSF_IP0);
+	irq_enable_hazard();
+
+	/* force broadcast timer */
+	clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_FORCE, &cpu);
+}
+
+static void jz4780_send_ipi_single_locked(int cpu, unsigned int action)
+{
+	u32 mbox;
+
+	switch (cpu) {
+	case 0:
+		mbox = read_c0_mailbox0();
+		write_c0_mailbox0(mbox | action);
+		break;
+	case 1:
+		mbox = read_c0_mailbox1();
+		write_c0_mailbox1(mbox | action);
+		break;
+	default:
+		panic("unhandled cpu %d!", cpu);
+	}
+}
+
+static void jz4780_send_ipi_single(int cpu, unsigned int action)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&smp_lock, flags);
+	jz4780_send_ipi_single_locked(cpu, action);
+	spin_unlock_irqrestore(&smp_lock, flags);
+}
+
+static void jz4780_send_ipi_mask(const struct cpumask *mask,
+				 unsigned int action)
+{
+	unsigned long flags;
+	int cpu;
+
+	spin_lock_irqsave(&smp_lock, flags);
+
+	for_each_cpu(cpu, mask)
+		jz4780_send_ipi_single_locked(cpu, action);
+
+	spin_unlock_irqrestore(&smp_lock, flags);
+}
+
+static struct plat_smp_ops jz4780_smp_ops = {
+	.send_ipi_single = jz4780_send_ipi_single,
+	.send_ipi_mask = jz4780_send_ipi_mask,
+	.init_secondary = jz4780_init_secondary,
+	.smp_finish = jz4780_smp_finish,
+	.boot_secondary = jz4780_boot_secondary,
+	.smp_setup = jz4780_smp_setup,
+	.prepare_cpus = jz4780_smp_prepare_cpus,
+};
+
+void jz4780_smp_init(void)
+{
+	register_smp_ops(&jz4780_smp_ops);
+}
diff -urN a/arch/mips/jz4780/smp-entry.S b/arch/mips/jz4780/smp-entry.S
--- a/arch/mips/jz4780/smp-entry.S	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/mips/jz4780/smp-entry.S	2014-11-18 19:24:06.442229813 +0100
@@ -0,0 +1,72 @@
+/*
+ * JZ4780 SMP entry point
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/addrspace.h>
+#include <asm/asm.h>
+#include <asm/asmmacro.h>
+#include <asm/cacheops.h>
+#include <asm/mipsregs.h>
+
+#define CACHE_SIZE (32 * 1024)
+#define CACHE_LINESIZE 32
+
+.extern jz4780_cpu_entry_sp
+.extern jz4780_cpu_entry_gp
+
+.section .text.smp-entry
+.balign 0x10000
+.set noreorder
+LEAF(jz4780_secondary_cpu_entry)
+	mtc0	zero, CP0_CAUSE
+
+	li	t0, ST0_CU0
+	mtc0	t0, CP0_STATUS
+
+	/* cache setup */
+	li	t0, KSEG0
+	ori	t1, t0, CACHE_SIZE
+	mtc0	zero, CP0_TAGLO, 0
+1:	cache	Index_Store_Tag_I, 0(t0)
+	cache	Index_Store_Tag_D, 0(t0)
+	bne	t0, t1, 1b
+	 addiu	t0, t0, CACHE_LINESIZE
+
+	/* kseg0 cache attribute */
+	mfc0	t0, CP0_CONFIG, 0
+	ori	t0, t0, CONF_CM_CACHABLE_NONCOHERENT
+	mtc0	t0, CP0_CONFIG, 0
+
+	/* pagemask */
+	mtc0	zero, CP0_PAGEMASK, 0
+
+	/* retrieve sp */
+	la	t0, jz4780_cpu_entry_sp
+	lw	sp, 0(t0)
+
+	/* retrieve gp */
+	la	t0, jz4780_cpu_entry_gp
+	lw	gp, 0(t0)
+
+	/* off we go! */
+	j	smp_bootstrap
+	 nop
+	END(jz4780_secondary_cpu_entry)
diff -urN a/arch/mips/Kbuild.platforms b/arch/mips/Kbuild.platforms
--- a/arch/mips/Kbuild.platforms	2014-11-09 23:55:29.000000000 +0100
+++ b/arch/mips/Kbuild.platforms	2014-11-18 19:24:06.470229938 +0100
@@ -11,6 +11,7 @@
 platforms += emma
 platforms += jazz
 platforms += jz4740
+platforms += jz4780
 platforms += lantiq
 platforms += lasat
 platforms += loongson
diff -urN a/arch/mips/Kconfig b/arch/mips/Kconfig
--- a/arch/mips/Kconfig	2014-11-18 19:15:12.000000000 +0100
+++ b/arch/mips/Kconfig	2014-11-18 19:24:06.478229987 +0100
@@ -248,6 +248,29 @@
 	select HAVE_CLK
 	select GENERIC_IRQ_CHIP
 
+config MACH_JZ4780
+	bool "Ingenic JZ4780 based machines"
+	select ARCH_REQUIRE_GPIOLIB
+	select CLKSRC_OF
+	select COMMON_CLK
+	select DMA_NONCOHERENT
+	select GENERIC_CLOCKEVENTS_BROADCAST if SMP
+	select INIT_ALL_POSSIBLE
+	select IRQ_CPU
+	select MIPS_CPU_SCACHE
+	select NR_CPUS_DEFAULT_2
+	select PINCTRL
+	select PINCTRL_JZ4780
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_SMP
+	select SYS_SUPPORTS_ZBOOT_UART16550
+	select USE_OF
+
 config LANTIQ
 	bool "Lantiq based platforms"
 	select DMA_NONCOHERENT
@@ -840,6 +863,7 @@
 source "arch/mips/bcm63xx/Kconfig"
 source "arch/mips/jazz/Kconfig"
 source "arch/mips/jz4740/Kconfig"
+source "arch/mips/jz4780/Kconfig"
 source "arch/mips/lantiq/Kconfig"
 source "arch/mips/lasat/Kconfig"
 source "arch/mips/pmcs-msp71xx/Kconfig"
diff -urN a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
--- a/arch/mips/kernel/idle.c	2014-11-09 23:55:29.000000000 +0100
+++ b/arch/mips/kernel/idle.c	2014-11-18 19:24:06.482230001 +0100
@@ -70,6 +70,28 @@
 	local_irq_enable();
 }
 
+extern void (*r4k_blast_dcache)(void);
+
+/*
+ * The Ingenic jz47xx SMP variant has to invalidate the data cache before
+ * executing wait. The CPU & cache clock will be gated until we return from
+ * the wait, and if another core attempts to access data from our data cache
+ * during this time then it will lock up.
+ */
+static void jz_wait_irqoff(void)
+{
+	r4k_blast_dcache();
+
+	if (!need_resched())
+		__asm__(
+		"	.set	push		\n"
+		"	.set	mips3		\n"
+		"	sync			\n"
+		"	wait			\n"
+		"	.set	pop		\n");
+	local_irq_enable();
+}
+
 /*
  * The RM7000 variant has to handle erratum 38.	 The workaround is to not
  * have any pending stores when the WAIT instruction is executed.
@@ -165,7 +187,6 @@
 	case CPU_CAVIUM_OCTEON_PLUS:
 	case CPU_CAVIUM_OCTEON2:
 	case CPU_CAVIUM_OCTEON3:
-	case CPU_JZRISC:
 	case CPU_LOONGSON1:
 	case CPU_XLR:
 	case CPU_XLP:
@@ -221,6 +242,12 @@
 		   cpu_wait = r4k_wait;
 		 */
 		break;
+	case CPU_JZRISC:
+		if (NR_CPUS > 1)
+			cpu_wait = jz_wait_irqoff;
+		else
+			cpu_wait = r4k_wait;
+		break;
 	default:
 		break;
 	}
