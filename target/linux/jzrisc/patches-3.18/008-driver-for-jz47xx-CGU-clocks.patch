diff -urN a/drivers/clk/jz47xx/jz4780-cgu.c b/drivers/clk/jz47xx/jz4780-cgu.c
--- a/drivers/clk/jz47xx/jz4780-cgu.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/clk/jz47xx/jz4780-cgu.c	2014-11-18 21:54:02.666958544 +0100
@@ -0,0 +1,923 @@
+/*
+ * JZ4780 SoC CGU driver
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <asm/mach-jz4780/jz4780-cgu.h>
+#include <dt-bindings/clock/jz4780-cgu.h>
+#include "jz47xx-cgu.h"
+
+static struct jz47xx_cgu *cgu;
+
+static u8 jz4780_otg_phy_get_parent(struct clk_hw *hw)
+{
+	/* we only use CLKCORE, revisit if that ever changes */
+	return 0;
+}
+
+static int jz4780_otg_phy_set_parent(struct clk_hw *hw, u8 idx)
+{
+	unsigned long flags;
+	u32 usbpcr1;
+
+	if (idx > 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&cgu->power_lock, flags);
+
+	usbpcr1 = readl(cgu->base + CGU_REG_USBPCR1);
+	usbpcr1 &= ~USBPCR1_REFCLKSEL_MASK;
+	/* we only use CLKCORE */
+	usbpcr1 |= USBPCR1_REFCLKSEL_CORE;
+	writel(usbpcr1, cgu->base + CGU_REG_USBPCR1);
+
+	spin_unlock_irqrestore(&cgu->power_lock, flags);
+	return 0;
+}
+
+static unsigned long jz4780_otg_phy_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	u32 usbpcr1;
+	unsigned refclk_div;
+
+	usbpcr1 = readl(cgu->base + CGU_REG_USBPCR1);
+	refclk_div = usbpcr1 & USBPCR1_REFCLKDIV_MASK;
+
+	switch (refclk_div) {
+	case USBPCR1_REFCLKDIV_12:
+		return 12000000;
+
+	case USBPCR1_REFCLKDIV_24:
+		return 24000000;
+
+	case USBPCR1_REFCLKDIV_48:
+		return 48000000;
+
+	case USBPCR1_REFCLKDIV_19_2:
+		return 19200000;
+	}
+
+	BUG();
+	return parent_rate;
+}
+
+static long jz4780_otg_phy_round_rate(struct clk_hw *hw, unsigned long req_rate,
+				      unsigned long *parent_rate)
+{
+	if (req_rate < 15600000)
+		return 12000000;
+
+	if (req_rate < 21600000)
+		return 19200000;
+
+	if (req_rate < 36000000)
+		return 24000000;
+
+	return 48000000;
+}
+
+static int jz4780_otg_phy_set_rate(struct clk_hw *hw, unsigned long req_rate,
+				   unsigned long parent_rate)
+{
+	unsigned long flags;
+	u32 usbpcr1, div_bits;
+
+	switch (req_rate) {
+	case 12000000:
+		div_bits = USBPCR1_REFCLKDIV_12;
+		break;
+
+	case 19200000:
+		div_bits = USBPCR1_REFCLKDIV_19_2;
+		break;
+
+	case 24000000:
+		div_bits = USBPCR1_REFCLKDIV_24;
+		break;
+
+	case 48000000:
+		div_bits = USBPCR1_REFCLKDIV_48;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&cgu->power_lock, flags);
+
+	usbpcr1 = readl(cgu->base + CGU_REG_USBPCR1);
+	usbpcr1 &= ~USBPCR1_REFCLKDIV_MASK;
+	usbpcr1 |= div_bits;
+	writel(usbpcr1, cgu->base + CGU_REG_USBPCR1);
+
+	spin_unlock_irqrestore(&cgu->power_lock, flags);
+	return 0;
+}
+
+struct clk_ops jz4780_otg_phy_ops = {
+	.get_parent = jz4780_otg_phy_get_parent,
+	.set_parent = jz4780_otg_phy_set_parent,
+
+	.recalc_rate = jz4780_otg_phy_recalc_rate,
+	.round_rate = jz4780_otg_phy_round_rate,
+	.set_rate = jz4780_otg_phy_set_rate,
+};
+
+static void jz4780_pll_get_cfg(void __iomem *reg,
+			       struct jz47xx_cgu_pll_cfg *cfg)
+{
+	u32 ctl = readl(reg);
+
+	cfg->m = ((ctl & PLLCTL_M_MASK) >> PLLCTL_M_SHIFT) + 1;
+	cfg->n = ((ctl & PLLCTL_N_MASK) >> PLLCTL_N_SHIFT) + 1;
+	cfg->od = ((ctl & PLLCTL_OD_MASK) >> PLLCTL_OD_SHIFT) + 1;
+	cfg->bypass = !!(ctl & PLLCTL_BYPASS);
+	cfg->enable = !!(ctl & PLLCTL_ENABLE);
+}
+
+static int jz4780_pll_set_cfg(void __iomem *reg,
+			      const struct jz47xx_cgu_pll_cfg *cfg)
+{
+	u32 ctl = readl(reg);
+	const unsigned timeout = 100;
+	unsigned i;
+
+	ctl &= ~(PLLCTL_M_MASK | PLLCTL_N_MASK | PLLCTL_OD_MASK);
+	ctl &= ~(PLLCTL_BYPASS | PLLCTL_ENABLE);
+
+	ctl |= cfg->m << PLLCTL_M_SHIFT;
+	ctl |= cfg->n << PLLCTL_N_SHIFT;
+	ctl |= cfg->od << PLLCTL_OD_SHIFT;
+
+	if (cfg->bypass)
+		ctl |= PLLCTL_BYPASS;
+	if (cfg->enable)
+		ctl |= PLLCTL_ENABLE;
+
+	/* TODO: set the AF_MODE bit? */
+
+	writel(ctl, reg);
+
+	if (cfg->enable) {
+		/* wait for the PLL to stabilise */
+		for (i = 0; i < timeout; i++) {
+			if (readl(reg) & PLLCTL_ON)
+				break;
+			mdelay(1);
+		}
+
+		if (i == timeout)
+			return -EBUSY;
+	}
+
+	return 0;
+}
+
+static const struct jz47xx_cgu_clk_info jz4780_cgu_clocks[] = {
+
+	/* External clocks */
+
+	[JZ4780_CLK_EXCLK] = { "exclk", CGU_CLK_EXT },
+	[JZ4780_CLK_RTCLK] = { "rtclk", CGU_CLK_EXT },
+
+	/* PLLs */
+
+#define DEF_PLL(name) { \
+	.max_m = (1 << 13), \
+	.max_n = (1 << 6), \
+	.max_od = (1 << 4), \
+	.reg = CGU_REG_ ## name, \
+	.get_cfg = jz4780_pll_get_cfg, \
+	.set_cfg = jz4780_pll_set_cfg, \
+}
+
+	[JZ4780_CLK_APLL] = {
+		"apll", CGU_CLK_PLL,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.pll = DEF_PLL(APLL),
+	},
+
+	[JZ4780_CLK_MPLL] = {
+		"mpll", CGU_CLK_PLL,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.pll = DEF_PLL(MPLL),
+	},
+
+	[JZ4780_CLK_EPLL] = {
+		"epll", CGU_CLK_PLL,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.pll = DEF_PLL(EPLL),
+	},
+
+	[JZ4780_CLK_VPLL] = {
+		"vpll", CGU_CLK_PLL,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.pll = DEF_PLL(VPLL),
+	},
+
+#undef DEF_PLL
+
+	/* Custom (SoC-specific) OTG PHY */
+
+	[JZ4780_CLK_OTGPHY] = {
+		"otg_phy", CGU_CLK_CUSTOM,
+		.parents = { -1, -1, JZ4780_CLK_EXCLK, -1 },
+		.custom = { &jz4780_otg_phy_ops },
+	},
+
+	/* Muxes & dividers */
+
+	[JZ4780_CLK_SCLKA] = {
+		"sclk_a", CGU_CLK_MUX,
+		.parents = { -1, JZ4780_CLK_APLL, JZ4780_CLK_EXCLK,
+			     JZ4780_CLK_RTCLK },
+		.mux = { CGU_REG_CLOCKCONTROL, 30, 2 },
+	},
+
+	[JZ4780_CLK_CPUMUX] = {
+		"cpumux", CGU_CLK_MUX,
+		.parents = { -1, JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL,
+			     JZ4780_CLK_EPLL },
+		.mux = { CGU_REG_CLOCKCONTROL, 28, 2 },
+	},
+
+	[JZ4780_CLK_CPU] = {
+		"cpu", CGU_CLK_DIV,
+		.parents = { JZ4780_CLK_CPUMUX, -1 },
+		.div = { CGU_REG_CLOCKCONTROL, 0, 4, 22, -1, -1 },
+	},
+
+	[JZ4780_CLK_L2CACHE] = {
+		"l2cache", CGU_CLK_DIV,
+		.parents = { JZ4780_CLK_CPUMUX, -1 },
+		.div = { CGU_REG_CLOCKCONTROL, 4, 4, -1, -1, -1 },
+	},
+
+	[JZ4780_CLK_AHB0] = {
+		"ahb0", CGU_CLK_MUX | CGU_CLK_DIV,
+		.parents = { -1, JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL,
+			     JZ4780_CLK_EPLL },
+		.mux = { CGU_REG_CLOCKCONTROL, 26, 2 },
+		.div = { CGU_REG_CLOCKCONTROL, 8, 4, 21, -1, -1 },
+	},
+
+	[JZ4780_CLK_AHB2PMUX] = {
+		"ahb2_apb_mux", CGU_CLK_MUX,
+		.parents = { -1, JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL,
+			     JZ4780_CLK_RTCLK },
+		.mux = { CGU_REG_CLOCKCONTROL, 24, 2 },
+	},
+
+	[JZ4780_CLK_AHB2] = {
+		"ahb2", CGU_CLK_DIV,
+		.parents = { JZ4780_CLK_AHB2PMUX, -1 },
+		.div = { CGU_REG_CLOCKCONTROL, 12, 4, 20, -1, -1 },
+	},
+
+	[JZ4780_CLK_PCLK] = {
+		"pclk", CGU_CLK_DIV,
+		.parents = { JZ4780_CLK_AHB2PMUX, -1 },
+		.div = { CGU_REG_CLOCKCONTROL, 16, 4, 20, -1, -1 },
+	},
+
+	[JZ4780_CLK_DDR] = {
+		"ddr", CGU_CLK_MUX | CGU_CLK_DIV,
+		.parents = { -1, JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL, -1 },
+		.mux = { CGU_REG_DDRCDR, 30, 2 },
+		.div = { CGU_REG_DDRCDR, 0, 4, 29, 28, 27 },
+	},
+
+	[JZ4780_CLK_VPU] = {
+		"vpu", CGU_CLK_MUX | CGU_CLK_DIV | CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL,
+			     JZ4780_CLK_EPLL, -1 },
+		.mux = { CGU_REG_VPUCDR, 30, 2 },
+		.div = { CGU_REG_VPUCDR, 0, 4, 29, 28, 27 },
+		.gate_bit = 32 + 2,
+	},
+
+	[JZ4780_CLK_I2SPLL] = {
+		"i2s_pll", CGU_CLK_MUX | CGU_CLK_DIV,
+		.parents = { JZ4780_CLK_SCLKA, JZ4780_CLK_EPLL, -1 },
+		.mux = { CGU_REG_I2SCDR, 30, 1 },
+		.div = { CGU_REG_I2SCDR, 0, 8, 29, 28, 27 },
+	},
+
+	[JZ4780_CLK_I2S] = {
+		"i2s", CGU_CLK_MUX,
+		.parents = { JZ4780_CLK_EXCLK, JZ4780_CLK_I2SPLL, -1 },
+		.mux = { CGU_REG_I2SCDR, 31, 1 },
+	},
+
+	[JZ4780_CLK_LCD0PIXCLK] = {
+		"lcd0pixclk", CGU_CLK_MUX | CGU_CLK_DIV,
+		.parents = { JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL,
+			     JZ4780_CLK_VPLL, -1 },
+		.mux = { CGU_REG_LP0CDR, 30, 2 },
+		.div = { CGU_REG_LP0CDR, 0, 8, 28, 27, 26 },
+	},
+
+	[JZ4780_CLK_LCD1PIXCLK] = {
+		"lcd1pixclk", CGU_CLK_MUX | CGU_CLK_DIV,
+		.parents = { JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL,
+			     JZ4780_CLK_VPLL, -1 },
+		.mux = { CGU_REG_LP1CDR, 30, 2 },
+		.div = { CGU_REG_LP1CDR, 0, 8, 28, 27, 26 },
+	},
+
+	[JZ4780_CLK_MSCMUX] = {
+		"msc_mux", CGU_CLK_MUX,
+		.parents = { -1, JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL, -1 },
+		.mux = { CGU_REG_MSC0CDR, 30, 2 },
+	},
+
+	[JZ4780_CLK_MSC0] = {
+		"msc0", CGU_CLK_DIV | CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_MSCMUX, -1 },
+		.div = { CGU_REG_MSC0CDR, 0, 8, 29, 28, 27 },
+		.gate_bit = 3,
+	},
+
+	[JZ4780_CLK_MSC1] = {
+		"msc1", CGU_CLK_DIV | CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_MSCMUX, -1 },
+		.div = { CGU_REG_MSC1CDR, 0, 8, 29, 28, 27 },
+		.gate_bit = 11,
+	},
+
+	[JZ4780_CLK_MSC2] = {
+		"msc2", CGU_CLK_DIV | CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_MSCMUX, -1 },
+		.div = { CGU_REG_MSC2CDR, 0, 8, 29, 28, 27 },
+		.gate_bit = 12,
+	},
+
+	[JZ4780_CLK_UHC] = {
+		"uhc", CGU_CLK_MUX | CGU_CLK_DIV | CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL,
+			     JZ4780_CLK_EPLL, JZ4780_CLK_OTGPHY },
+		.mux = { CGU_REG_UHCCDR, 30, 2 },
+		.div = { CGU_REG_UHCCDR, 0, 8, 29, 28, 27 },
+		.gate_bit = 24,
+	},
+
+	[JZ4780_CLK_SSIPLL] = {
+		"ssi_pll", CGU_CLK_MUX | CGU_CLK_DIV,
+		.parents = { JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL, -1 },
+		.mux = { CGU_REG_SSICDR, 30, 1 },
+		.div = { CGU_REG_SSICDR, 0, 8, 29, 28, 27 },
+	},
+
+	[JZ4780_CLK_SSI] = {
+		"ssi", CGU_CLK_MUX,
+		.parents = { JZ4780_CLK_EXCLK, JZ4780_CLK_SSIPLL, -1 },
+		.mux = { CGU_REG_SSICDR, 31, 1 },
+	},
+
+	[JZ4780_CLK_CIMMCLK] = {
+		"cim_mclk", CGU_CLK_MUX | CGU_CLK_DIV,
+		.parents = { JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL, -1 },
+		.mux = { CGU_REG_CIMCDR, 31, 1 },
+		.div = { CGU_REG_CIMCDR, 0, 8, 30, 29, 28 },
+	},
+
+	[JZ4780_CLK_PCMPLL] = {
+		"pcm_pll", CGU_CLK_MUX | CGU_CLK_DIV,
+		.parents = { JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL,
+			     JZ4780_CLK_EPLL, JZ4780_CLK_VPLL },
+		.mux = { CGU_REG_PCMCDR, 29, 2 },
+		.div = { CGU_REG_PCMCDR, 0, 8, 28, 27, 26 },
+	},
+
+	[JZ4780_CLK_PCM] = {
+		"pcm", CGU_CLK_MUX | CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, JZ4780_CLK_PCMPLL, -1 },
+		.mux = { CGU_REG_PCMCDR, 31, 1 },
+		.gate_bit = 32 + 3,
+	},
+
+	[JZ4780_CLK_GPU] = {
+		"gpu", CGU_CLK_MUX | CGU_CLK_DIV | CGU_CLK_GATE,
+		.parents = { -1, JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL,
+			     JZ4780_CLK_EPLL },
+		.mux = { CGU_REG_GPUCDR, 30, 2 },
+		.div = { CGU_REG_GPUCDR, 0, 4, 29, 28, 27 },
+		.gate_bit = 32 + 4,
+	},
+
+	[JZ4780_CLK_HDMI] = {
+		"hdmi", CGU_CLK_MUX | CGU_CLK_DIV | CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL,
+			     JZ4780_CLK_VPLL, -1 },
+		.mux = { CGU_REG_HDMICDR, 30, 2 },
+		.div = { CGU_REG_HDMICDR, 0, 8, 29, 28, 26 },
+		.gate_bit = 32 + 9,
+	},
+
+	[JZ4780_CLK_BCH] = {
+		"bch", CGU_CLK_MUX | CGU_CLK_DIV | CGU_CLK_GATE,
+		.parents = { -1, JZ4780_CLK_SCLKA, JZ4780_CLK_MPLL,
+			     JZ4780_CLK_EPLL },
+		.mux = { CGU_REG_BCHCDR, 30, 2 },
+		.div = { CGU_REG_BCHCDR, 0, 4, 29, 28, 27 },
+		.gate_bit = 1,
+	},
+
+	/* Gate-only clocks */
+
+	[JZ4780_CLK_NEMC] = {
+		"nemc", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_AHB2, -1 },
+		.gate_bit = 0,
+	},
+
+	[JZ4780_CLK_OTG0] = {
+		"otg0", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 2,
+	},
+
+	[JZ4780_CLK_SSI0] = {
+		"ssi0", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_SSI, -1 },
+		.gate_bit = 4,
+	},
+
+	[JZ4780_CLK_SMB0] = {
+		"smb0", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_PCLK, -1 },
+		.gate_bit = 5,
+	},
+
+	[JZ4780_CLK_SMB1] = {
+		"smb1", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_PCLK, -1 },
+		.gate_bit = 6,
+	},
+
+	[JZ4780_CLK_SCC] = {
+		"scc", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 7,
+	},
+
+	[JZ4780_CLK_AIC] = {
+		"aic", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 8,
+	},
+
+	[JZ4780_CLK_TSSI0] = {
+		"tssi0", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 9,
+	},
+
+	[JZ4780_CLK_OWI] = {
+		"owi", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 10,
+	},
+
+	[JZ4780_CLK_KBC] = {
+		"kbc", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 13,
+	},
+
+	[JZ4780_CLK_SADC] = {
+		"sadc", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 14,
+	},
+
+	[JZ4780_CLK_UART0] = {
+		"uart0", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 15,
+	},
+
+	[JZ4780_CLK_UART1] = {
+		"uart1", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 16,
+	},
+
+	[JZ4780_CLK_UART2] = {
+		"uart2", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 17,
+	},
+
+	[JZ4780_CLK_UART3] = {
+		"uart3", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 18,
+	},
+
+	[JZ4780_CLK_SSI1] = {
+		"ssi1", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_SSI, -1 },
+		.gate_bit = 19,
+	},
+
+	[JZ4780_CLK_SSI2] = {
+		"ssi2", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_SSI, -1 },
+		.gate_bit = 20,
+	},
+
+	[JZ4780_CLK_PDMA] = {
+		"pdma", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 21,
+	},
+
+	[JZ4780_CLK_GPS] = {
+		"gps", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 22,
+	},
+
+	[JZ4780_CLK_MAC] = {
+		"mac", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 23,
+	},
+
+	[JZ4780_CLK_SMB2] = {
+		"smb2", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_PCLK, -1 },
+		.gate_bit = 25,
+	},
+
+	[JZ4780_CLK_CIM] = {
+		"cim", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 26,
+	},
+
+	[JZ4780_CLK_LCD] = {
+		"lcd", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 28,
+	},
+
+	[JZ4780_CLK_TVE] = {
+		"tve", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_LCD, -1 },
+		.gate_bit = 27,
+	},
+
+	[JZ4780_CLK_IPU] = {
+		"ipu", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 29,
+	},
+
+	[JZ4780_CLK_DDR0] = {
+		"ddr0", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_DDR, -1 },
+		.gate_bit = 30,
+	},
+
+	[JZ4780_CLK_DDR1] = {
+		"ddr1", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_DDR, -1 },
+		.gate_bit = 31,
+	},
+
+	[JZ4780_CLK_SMB3] = {
+		"smb3", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_PCLK, -1 },
+		.gate_bit = 32 + 0,
+	},
+
+	[JZ4780_CLK_TSSI1] = {
+		"tssi1", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 32 + 1,
+	},
+
+	[JZ4780_CLK_COMPRESS] = {
+		"compress", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 32 + 5,
+	},
+
+	[JZ4780_CLK_AIC1] = {
+		"aic1", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 32 + 6,
+	},
+
+	[JZ4780_CLK_GPVLC] = {
+		"gpvlc", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 32 + 7,
+	},
+
+	[JZ4780_CLK_OTG1] = {
+		"otg1", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 32 + 8,
+	},
+
+	[JZ4780_CLK_UART4] = {
+		"uart4", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 32 + 10,
+	},
+
+	[JZ4780_CLK_AHBMON] = {
+		"ahb_mon", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 32 + 11,
+	},
+
+	[JZ4780_CLK_SMB4] = {
+		"smb4", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_PCLK, -1 },
+		.gate_bit = 32 + 12,
+	},
+
+	[JZ4780_CLK_DES] = {
+		"des", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 32 + 13,
+	},
+
+	[JZ4780_CLK_X2D] = {
+		"x2d", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_EXCLK, -1 },
+		.gate_bit = 32 + 14,
+	},
+
+	[JZ4780_CLK_CORE1] = {
+		"core1", CGU_CLK_GATE,
+		.parents = { JZ4780_CLK_CPU, -1 },
+		.gate_bit = 32 + 15,
+	},
+
+};
+
+static void __init jz4780_cgu_init(struct device_node *np)
+{
+	int retval;
+	cgu = jz47xx_cgu_new(jz4780_cgu_clocks, ARRAY_SIZE(jz4780_cgu_clocks),
+			     np);
+	if (!cgu)
+		pr_err("%s: failed to initialise CGU\n", __func__);
+
+	retval = jz47xx_cgu_register_clocks(cgu);
+	if (retval)
+		pr_err("%s: failed to register CGU Clocks\n", __func__);
+
+	clk_set_parent(cgu->clocks.clks[JZ4780_CLK_UHC],
+		       cgu->clocks.clks[JZ4780_CLK_MPLL]);
+}
+CLK_OF_DECLARE(jz4780_cgu, "ingenic,jz4780-cgu", jz4780_cgu_init);
+
+int jz4780_cgu_set_usb_suspend(enum jz4780_usb_port port, bool suspend)
+{
+	unsigned long flags;
+	u32 opcr, bit;
+
+	switch (port) {
+	case USB_PORT_OTG:
+		bit = OPCR_SPENDN0;
+		break;
+
+	case USB_PORT_HOST:
+		bit = OPCR_SPENDN1;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&cgu->power_lock, flags);
+
+	opcr = readl(cgu->base + CGU_REG_OPCR);
+	if (suspend)
+		opcr &= ~bit;
+	else
+		opcr |= bit;
+	writel(opcr, cgu->base + CGU_REG_OPCR);
+
+	spin_unlock_irqrestore(&cgu->power_lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(jz4780_cgu_set_usb_suspend);
+
+int jz4780_cgu_set_usb_otg_mode(enum jz4780_usb_otg_mode mode)
+{
+	unsigned long flags;
+	u32 usbpcr1;
+	int retval = 0;
+
+	spin_lock_irqsave(&cgu->power_lock, flags);
+	usbpcr1 = readl(cgu->base + CGU_REG_USBPCR1);
+
+	switch (mode) {
+	case USB_OTG_MODE_MENTOR:
+		usbpcr1 &= USBPCR1_USB_SEL;
+		break;
+
+	case USB_OTG_MODE_SYNOPSYS:
+		usbpcr1 |= USBPCR1_USB_SEL;
+		break;
+
+	default:
+		retval = -EINVAL;
+		goto out;
+	}
+
+	writel(usbpcr1, cgu->base + CGU_REG_USBPCR1);
+
+out:
+	spin_unlock_irqrestore(&cgu->power_lock, flags);
+
+	return retval;
+}
+EXPORT_SYMBOL_GPL(jz4780_cgu_set_usb_otg_mode);
+
+int jz4780_cgu_set_usb_utmi_bus_width(enum jz4780_usb_port port,
+				      enum jz4780_usb_utmi_bus_width width)
+{
+	unsigned long flags;
+	u32 usbpcr1, bit;
+	int retval = 0;
+
+	switch (port) {
+	case USB_PORT_OTG:
+		bit = USBPCR1_WORD_IF0;
+		break;
+
+	case USB_PORT_HOST:
+		bit = USBPCR1_WORD_IF1;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&cgu->power_lock, flags);
+	usbpcr1 = readl(cgu->base + CGU_REG_USBPCR1);
+
+	switch (width) {
+	case USB_PORT_UTMI_BUS_WIDTH_8:
+		usbpcr1 &= bit;
+		break;
+
+	case USB_PORT_UTMI_BUS_WIDTH_16:
+		usbpcr1 |= bit;
+		break;
+
+	default:
+		retval = -EINVAL;
+		goto out_unlock;
+	}
+
+	writel(usbpcr1, cgu->base + CGU_REG_USBPCR1);
+
+out_unlock:
+	spin_unlock_irqrestore(&cgu->power_lock, flags);
+	return retval;
+}
+EXPORT_SYMBOL_GPL(jz4780_cgu_set_usb_utmi_bus_width);
+
+void jz4780_cgu_set_usb_iddigfil(u32 value)
+{
+	unsigned long flags;
+	u32 usbvbfil;
+
+	spin_lock_irqsave(&cgu->power_lock, flags);
+
+	usbvbfil = readl(cgu->base + CGU_REG_USBPCR1);
+	usbvbfil &= ~USBVBFIL_IDDIGFIL_MASK;
+	usbvbfil |= value;
+	writel(usbvbfil, cgu->base + CGU_REG_USBVBFIL);
+
+	spin_unlock_irqrestore(&cgu->power_lock, flags);
+}
+EXPORT_SYMBOL_GPL(jz4780_cgu_set_usb_iddigfil);
+
+void jz4780_cgu_set_usb_usbvbfil(u32 value)
+{
+	unsigned long flags;
+	u32 usbvbfil;
+
+	spin_lock_irqsave(&cgu->power_lock, flags);
+
+	usbvbfil = readl(cgu->base + CGU_REG_USBPCR1);
+	usbvbfil &= ~USBVBFIL_USBVBFIL_MASK;
+	usbvbfil |= value;
+	writel(usbvbfil, cgu->base + CGU_REG_USBVBFIL);
+
+	spin_unlock_irqrestore(&cgu->power_lock, flags);
+}
+EXPORT_SYMBOL_GPL(jz4780_cgu_set_usb_usbvbfil);
+
+void jz4780_cgu_set_usb_usbrdt(u32 value)
+{
+	unsigned long flags;
+	u32 usbrdt;
+
+	spin_lock_irqsave(&cgu->power_lock, flags);
+
+	usbrdt = readl(cgu->base + CGU_REG_USBRDT);
+	usbrdt &= ~USBRDT_USBRDT_MASK;
+	usbrdt |= value;
+	writel(usbrdt, cgu->base + CGU_REG_USBRDT);
+
+	spin_unlock_irqrestore(&cgu->power_lock, flags);
+}
+EXPORT_SYMBOL_GPL(jz4780_cgu_set_usb_usbrdt);
+
+void jz4780_cgu_set_usb_vbfil_ld_en(bool enable)
+{
+	unsigned long flags;
+	u32 usbrdt;
+
+	spin_lock_irqsave(&cgu->power_lock, flags);
+
+	usbrdt = readl(cgu->base + CGU_REG_USBRDT);
+	usbrdt &= ~USBRDT_VBFIL_LD_EN;
+	usbrdt |= (enable & USBRDT_VBFIL_LD_EN);
+	writel(usbrdt, cgu->base + CGU_REG_USBRDT);
+
+	spin_unlock_irqrestore(&cgu->power_lock, flags);
+}
+EXPORT_SYMBOL_GPL(jz4780_cgu_set_usb_vbfil_ld_en);
+
+void jz4780_cgu_usb_reset(void)
+{
+	unsigned long flags;
+	u32 usbpcr;
+
+	spin_lock_irqsave(&cgu->power_lock, flags);
+	usbpcr = readl(cgu + CGU_REG_USBPCR);
+	writel(usbpcr | USBPCR_POR, cgu + CGU_REG_USBPCR);
+
+	mdelay(1);
+	usbpcr = readl(cgu + CGU_REG_USBPCR);
+	writel(usbpcr & (~USBPCR_POR), cgu + CGU_REG_USBPCR);
+	spin_unlock_irqrestore(&cgu->power_lock, flags);
+}
+EXPORT_SYMBOL_GPL(jz4780_cgu_usb_reset);
+
+int jz4780_cgu_set_usbpcr_param(u32 param, bool enable)
+{
+	unsigned long flags;
+	u32 usbpcr;
+
+	switch (param) {
+	case USBPCR_USB_MODE:
+	case USBPCR_COMMONONN:
+	case USBPCR_VBUSVLDEXT:
+	case USBPCR_VBUSVLDEXTSEL:
+	case USBPCR_OTG_DISABLE:
+	case USBPCR_TXPREEMPHTUNE:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&cgu->power_lock, flags);
+
+	usbpcr = readl(cgu->base + CGU_REG_USBPCR);
+
+	if (enable)
+		usbpcr |= param;
+	else
+		usbpcr &= ~param;
+
+	writel(usbpcr, cgu->base + CGU_REG_USBPCR);
+
+	spin_unlock_irqrestore(&cgu->power_lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(jz4780_cgu_set_usbpcr_param);
+
diff -urN a/drivers/clk/jz47xx/jz47xx-cgu.c b/drivers/clk/jz47xx/jz47xx-cgu.c
--- a/drivers/clk/jz47xx/jz47xx-cgu.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/clk/jz47xx/jz47xx-cgu.c	2014-11-18 21:54:45.791108177 +0100
@@ -0,0 +1,671 @@
+/*
+ * JZ47xx SoC CGU driver
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include "jz47xx-cgu.h"
+
+#define REG_CLKGR		0x20
+#define REG_CLKGR_STRIDE	0x8
+
+#define MHZ (1000 * 1000)
+
+/**
+ * jz47xx_cgu_gate_get - get the value of clock gate register bit
+ * @cgu: reference to the CGU whose registers should be read
+ * @idx: index of the gate bit
+ *
+ * Returns 1 if the gate bit is set, else 0. The index begins with 0 being
+ * bit 0 of CLKGR0, continuing from 32 for bit 0 of CLKGR1 etc. For example,
+ * the index of bit 9 of CLKGR1 would be (32+9) == 41.
+ *
+ * The caller must hold cgu->power_lock.
+ */
+static inline unsigned jz47xx_cgu_gate_get(struct jz47xx_cgu *cgu,
+					   unsigned idx)
+{
+	void __iomem *reg;
+	u32 bit, clkgr;
+
+	reg = cgu->base + REG_CLKGR + ((idx / 32) * REG_CLKGR_STRIDE);
+	bit = 1 << (idx % 32);
+	clkgr = readl(reg);
+	return !!(clkgr & bit);
+}
+
+/**
+ * jz47xx_cgu_gate_set - set the value of clock gate register bit
+ * @cgu: reference to the CGU whose registers should be modified
+ * @idx: index of the gate bit
+ * @val: non-zero to gate a clock, otherwise zero
+ *
+ * Sets the given gate bit in order to gate or ungate a clock. See
+ * jz47xx_cgu_gate_get for a description of the idx parameter.
+ *
+ * The caller must hold cgu->power_lock.
+ */
+static inline void jz47xx_cgu_gate_set(struct jz47xx_cgu *cgu,
+				       unsigned idx, unsigned val)
+{
+	void __iomem *reg;
+	u32 bit, clkgr;
+
+	reg = cgu->base + REG_CLKGR + ((idx / 32) * REG_CLKGR_STRIDE);
+	bit = 1 << (idx % 32);
+	clkgr = readl(reg);
+
+	if (val)
+		clkgr |= bit;
+	else
+		clkgr &= ~bit;
+
+	writel(clkgr, reg);
+}
+
+/*
+ * PLL operations
+ */
+
+static unsigned long jz47xx_pll_recalc_rate(struct clk_hw *hw,
+					    unsigned long parent_rate)
+{
+	struct jz47xx_clk *jz_clk = to_jz47xx_clk(hw);
+	struct jz47xx_cgu *cgu = jz_clk->cgu;
+	const struct jz47xx_cgu_clk_info *clk_info;
+	struct jz47xx_cgu_pll_cfg cfg;
+
+	clk_info = &cgu->clock_info[jz_clk->idx];
+	BUG_ON(clk_info->type != CGU_CLK_PLL);
+
+	clk_info->pll.get_cfg(cgu->base + clk_info->pll.reg, &cfg);
+
+	if (cfg.bypass)
+		return parent_rate;
+
+	if (!cfg.enable)
+		return 0;
+
+	return parent_rate * cfg.m / (cfg.n * cfg.od);
+}
+
+static unsigned long jz47xx_pll_calc(const struct jz47xx_cgu_clk_info *clk_info,
+				     unsigned long rate,
+				     unsigned long parent_rate,
+				     unsigned *pm, unsigned *pn, unsigned *pod)
+{
+	unsigned m, n, od;
+
+	/* deal with MHz */
+	rate -= (rate % MHZ);
+
+	m = rate / MHZ;
+	m = min_t(unsigned, m, clk_info->pll.max_m);
+	m = max_t(unsigned, m, 1);
+
+	n = parent_rate / MHZ;
+	n = min_t(unsigned, n, clk_info->pll.max_n);
+	n = max_t(unsigned, n, 1);
+
+	od = 1;
+
+	if (pm)
+		*pm = m;
+	if (pn)
+		*pn = n;
+	if (pod)
+		*pod = od;
+
+	return parent_rate * m / (n * od);
+}
+
+static long jz47xx_pll_round_rate(struct clk_hw *hw, unsigned long req_rate,
+				  unsigned long *prate)
+{
+	struct jz47xx_clk *jz_clk = to_jz47xx_clk(hw);
+	struct jz47xx_cgu *cgu = jz_clk->cgu;
+	const struct jz47xx_cgu_clk_info *clk_info;
+
+	clk_info = &cgu->clock_info[jz_clk->idx];
+	BUG_ON(clk_info->type != CGU_CLK_PLL);
+
+	return jz47xx_pll_calc(clk_info, req_rate, *prate, NULL, NULL, NULL);
+}
+
+static int jz47xx_pll_set_rate(struct clk_hw *hw, unsigned long req_rate,
+			       unsigned long parent_rate)
+{
+	struct jz47xx_clk *jz_clk = to_jz47xx_clk(hw);
+	struct jz47xx_cgu *cgu = jz_clk->cgu;
+	const struct jz47xx_cgu_clk_info *clk_info;
+	struct jz47xx_cgu_pll_cfg cfg;
+	unsigned long rate;
+
+	clk_info = &cgu->clock_info[jz_clk->idx];
+	BUG_ON(clk_info->type != CGU_CLK_PLL);
+
+	rate = jz47xx_pll_calc(clk_info, req_rate, parent_rate,
+			       &cfg.m, &cfg.n, &cfg.od);
+	if (rate != req_rate) {
+		pr_info("jz47xx-cgu: request '%s' rate %luHz, actual %luHz\n",
+			clk_info->name, req_rate, rate);
+	}
+
+	cfg.bypass = 0;
+	cfg.enable = 1;
+
+	return clk_info->pll.set_cfg(cgu->base + clk_info->pll.reg, &cfg);
+}
+
+static const struct clk_ops jz47xx_pll_ops = {
+	.recalc_rate = jz47xx_pll_recalc_rate,
+	.round_rate = jz47xx_pll_round_rate,
+	.set_rate = jz47xx_pll_set_rate,
+};
+
+/*
+ * Operations for all non-PLL clocks
+ */
+
+static u8 jz47xx_clk_get_parent(struct clk_hw *hw)
+{
+	struct jz47xx_clk *jz_clk = to_jz47xx_clk(hw);
+	struct jz47xx_cgu *cgu = jz_clk->cgu;
+	const struct jz47xx_cgu_clk_info *clk_info;
+	u32 reg;
+	u8 i, hw_idx, idx = 0;
+
+	clk_info = &cgu->clock_info[jz_clk->idx];
+
+	if (clk_info->type & CGU_CLK_MUX) {
+		reg = readl(cgu->base + clk_info->mux.reg);
+		hw_idx = (reg >> clk_info->mux.shift) &
+			 ((1 << clk_info->mux.bits) - 1);
+
+		/*
+		 * Convert the hardware index to the parent index by skipping
+		 * over any -1's in the parents array.
+		 */
+		for (i = 0; i < hw_idx; i++) {
+			if (clk_info->parents[i] != -1)
+				idx++;
+		}
+	}
+
+	return idx;
+}
+
+static int jz47xx_clk_set_parent(struct clk_hw *hw, u8 idx)
+{
+	struct jz47xx_clk *jz_clk = to_jz47xx_clk(hw);
+	struct jz47xx_cgu *cgu = jz_clk->cgu;
+	const struct jz47xx_cgu_clk_info *clk_info;
+	unsigned long flags;
+	u8 curr_idx, hw_idx, num_poss;
+	u32 reg, mask;
+
+	clk_info = &cgu->clock_info[jz_clk->idx];
+
+	if (clk_info->type & CGU_CLK_MUX) {
+		/*
+		 * Convert the parent index to the hardware index by adding
+		 * 1 for any -1 in the parents array preceeding the given
+		 * index. That is, we want the index of idx'th entry in
+		 * clk_info->parents which does not equal -1.
+		 */
+		hw_idx = curr_idx = 0;
+		num_poss = 1 << clk_info->mux.bits;
+		for (; (hw_idx < num_poss) && (curr_idx != idx); hw_idx++) {
+			if (clk_info->parents[hw_idx] == -1)
+				continue;
+			curr_idx++;
+		}
+
+		/* idx should always be a valid parent */
+		BUG_ON(curr_idx != idx);
+
+		mask = ((1 << clk_info->mux.bits) - 1) << clk_info->mux.shift;
+
+		spin_lock_irqsave(&cgu->divmux_lock, flags);
+
+		/* write the register */
+		reg = readl(cgu->base + clk_info->mux.reg);
+		reg &= ~mask;
+		reg |= hw_idx << clk_info->mux.shift;
+		writel(reg, cgu->base + clk_info->mux.reg);
+
+		spin_unlock_irqrestore(&cgu->divmux_lock, flags);
+		return 0;
+	}
+
+	return idx ? -EINVAL : 0;
+}
+
+static unsigned long jz47xx_clk_recalc_rate(struct clk_hw *hw,
+					    unsigned long parent_rate)
+{
+	struct jz47xx_clk *jz_clk = to_jz47xx_clk(hw);
+	struct jz47xx_cgu *cgu = jz_clk->cgu;
+	const struct jz47xx_cgu_clk_info *clk_info;
+	unsigned long rate = parent_rate;
+	u32 div_reg, div;
+
+	clk_info = &cgu->clock_info[jz_clk->idx];
+
+	if (clk_info->type & CGU_CLK_DIV) {
+		div_reg = readl(cgu->base + clk_info->div.reg);
+		div = (div_reg >> clk_info->div.shift) &
+		      ((1 << clk_info->div.bits) - 1);
+		div += 1;
+
+		rate /= div;
+	}
+
+	return rate;
+}
+
+static unsigned jz47xx_clk_calc_div(const struct jz47xx_cgu_clk_info *clk_info,
+				    unsigned long parent_rate,
+				    unsigned long req_rate)
+{
+	unsigned div;
+
+	/* calculate the divide that gets us closest */
+	div = DIV_ROUND_CLOSEST(parent_rate, req_rate);
+
+	/* and impose hardware constraints */
+	div = min_t(unsigned, div, 1 << clk_info->div.bits);
+	div = max_t(unsigned, div, 1);
+
+	return div;
+}
+
+static long jz47xx_clk_round_rate(struct clk_hw *hw, unsigned long req_rate,
+				  unsigned long *parent_rate)
+{
+	struct jz47xx_clk *jz_clk = to_jz47xx_clk(hw);
+	struct jz47xx_cgu *cgu = jz_clk->cgu;
+	const struct jz47xx_cgu_clk_info *clk_info;
+	long rate = req_rate;
+	unsigned div;
+
+	clk_info = &cgu->clock_info[jz_clk->idx];
+
+	if (clk_info->type & CGU_CLK_DIV) {
+		div = jz47xx_clk_calc_div(clk_info, *parent_rate, req_rate);
+		rate = *parent_rate / div;
+	}
+
+	return rate;
+}
+
+static int jz47xx_clk_set_rate(struct clk_hw *hw, unsigned long req_rate,
+			       unsigned long parent_rate)
+{
+	struct jz47xx_clk *jz_clk = to_jz47xx_clk(hw);
+	struct jz47xx_cgu *cgu = jz_clk->cgu;
+	const struct jz47xx_cgu_clk_info *clk_info;
+	const unsigned timeout = 100;
+	unsigned long rate, flags;
+	unsigned div, i;
+	u32 reg, mask;
+
+	clk_info = &cgu->clock_info[jz_clk->idx];
+
+	if (clk_info->type & CGU_CLK_DIV) {
+		div = jz47xx_clk_calc_div(clk_info, parent_rate, req_rate);
+		rate = parent_rate / div;
+
+		if (rate != req_rate)
+			return -EINVAL;
+
+		spin_lock_irqsave(&cgu->divmux_lock, flags);
+		reg = readl(cgu->base + clk_info->div.reg);
+
+		/* update the divide */
+		mask = (1 << clk_info->div.bits) - 1;
+		reg &= ~(mask << clk_info->div.shift);
+		reg |= (div - 1) << clk_info->div.shift;
+
+		/* clear the stop bit */
+		if (clk_info->div.stop_bit != -1)
+			reg &= ~(1 << clk_info->div.stop_bit);
+
+		/* set the change enable bit */
+		if (clk_info->div.ce_bit != -1)
+			reg |= 1 << clk_info->div.ce_bit;
+
+		/* update the hardware */
+		writel(reg, cgu->base + clk_info->div.reg);
+
+		/* wait for the change to take effect */
+		if (clk_info->div.busy_bit != -1) {
+			for (i = 0; i < timeout; i++) {
+				reg = readl(cgu->base + clk_info->div.reg);
+				if (!(reg & (1 << clk_info->div.busy_bit)))
+					break;
+				mdelay(1);
+			}
+			if (i == timeout)
+				return -EBUSY;
+		}
+
+		spin_unlock_irqrestore(&cgu->divmux_lock, flags);
+
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int jz47xx_clk_enable(struct clk_hw *hw)
+{
+	struct jz47xx_clk *jz_clk = to_jz47xx_clk(hw);
+	struct jz47xx_cgu *cgu = jz_clk->cgu;
+	const struct jz47xx_cgu_clk_info *clk_info;
+	unsigned long flags;
+
+	clk_info = &cgu->clock_info[jz_clk->idx];
+
+	if (clk_info->type & CGU_CLK_GATE) {
+		/* ungate the clock */
+		spin_lock_irqsave(&cgu->power_lock, flags);
+		jz47xx_cgu_gate_set(cgu, clk_info->gate_bit, 0);
+		spin_unlock_irqrestore(&cgu->power_lock, flags);
+	}
+
+	return 0;
+}
+
+static void jz47xx_clk_disable(struct clk_hw *hw)
+{
+	struct jz47xx_clk *jz_clk = to_jz47xx_clk(hw);
+	struct jz47xx_cgu *cgu = jz_clk->cgu;
+	const struct jz47xx_cgu_clk_info *clk_info;
+	unsigned long flags;
+
+	clk_info = &cgu->clock_info[jz_clk->idx];
+
+	if (clk_info->type & CGU_CLK_GATE) {
+		/* gate the clock */
+		spin_lock_irqsave(&cgu->power_lock, flags);
+		jz47xx_cgu_gate_set(cgu, clk_info->gate_bit, 1);
+		spin_unlock_irqrestore(&cgu->power_lock, flags);
+	}
+}
+
+static int jz47xx_clk_is_enabled(struct clk_hw *hw)
+{
+	struct jz47xx_clk *jz_clk = to_jz47xx_clk(hw);
+	struct jz47xx_cgu *cgu = jz_clk->cgu;
+	const struct jz47xx_cgu_clk_info *clk_info;
+	unsigned long flags;
+	int enabled = 1;
+
+	clk_info = &cgu->clock_info[jz_clk->idx];
+
+	if (clk_info->type & CGU_CLK_GATE) {
+		spin_lock_irqsave(&cgu->power_lock, flags);
+		enabled = !jz47xx_cgu_gate_get(cgu, clk_info->gate_bit);
+		spin_unlock_irqrestore(&cgu->power_lock, flags);
+	}
+
+	return enabled;
+}
+
+static const struct clk_ops jz47xx_clk_ops = {
+	.get_parent = jz47xx_clk_get_parent,
+	.set_parent = jz47xx_clk_set_parent,
+
+	.recalc_rate = jz47xx_clk_recalc_rate,
+	.round_rate = jz47xx_clk_round_rate,
+	.set_rate = jz47xx_clk_set_rate,
+
+	.enable = jz47xx_clk_enable,
+	.disable = jz47xx_clk_disable,
+	.is_enabled = jz47xx_clk_is_enabled,
+};
+
+/*
+ * Setup functions.
+ */
+
+static int register_clock(struct jz47xx_cgu *cgu, unsigned idx)
+{
+	const struct jz47xx_cgu_clk_info *clk_info = &cgu->clock_info[idx];
+	struct clk_init_data clk_init;
+	struct jz47xx_clk *jz_clk = NULL;
+	struct clk *clk, *parent;
+	const char *parent_names[4];
+	unsigned caps, i, num_possible;
+	int err = -EINVAL;
+
+	BUILD_BUG_ON(ARRAY_SIZE(clk_info->parents) > ARRAY_SIZE(parent_names));
+
+	if (clk_info->type == CGU_CLK_EXT) {
+		clk = of_clk_get_by_name(cgu->np, clk_info->name);
+		if (IS_ERR(clk)) {
+			pr_err("%s: no external clock '%s' provided\n",
+			       __func__, clk_info->name);
+			err = -ENODEV;
+			goto out;
+		}
+		err = clk_register_clkdev(clk, clk_info->name, NULL);
+		if (err) {
+			clk_put(clk);
+			goto out;
+		}
+		cgu->clocks.clks[idx] = clk;
+		return 0;
+	}
+
+	if (!clk_info->type) {
+		pr_err("%s: no clock type specified for '%s'\n", __func__,
+		       clk_info->name);
+		goto out;
+	}
+
+	jz_clk = kzalloc(sizeof(*jz_clk), GFP_KERNEL);
+	if (!jz_clk) {
+		pr_err("%s: failed to allocate struct jz47xx_clk\n", __func__);
+		err = -ENOMEM;
+		goto out;
+	}
+
+	jz_clk->hw.init = &clk_init;
+	jz_clk->cgu = cgu;
+	jz_clk->idx = idx;
+
+	clk_init.name = clk_info->name;
+	clk_init.flags = 0;
+	clk_init.parent_names = parent_names;
+
+	caps = clk_info->type;
+
+	if (caps & (CGU_CLK_MUX | CGU_CLK_CUSTOM)) {
+		clk_init.num_parents = 0;
+
+		if (caps & CGU_CLK_MUX)
+			num_possible = 1 << clk_info->mux.bits;
+		else
+			num_possible = ARRAY_SIZE(clk_info->parents);
+
+		for (i = 0; i < num_possible; i++) {
+			if (clk_info->parents[i] == -1)
+				continue;
+
+			parent = cgu->clocks.clks[clk_info->parents[i]];
+			parent_names[clk_init.num_parents] =
+				__clk_get_name(parent);
+			clk_init.num_parents++;
+		}
+
+		BUG_ON(!clk_init.num_parents);
+		BUG_ON(clk_init.num_parents > ARRAY_SIZE(parent_names));
+	} else {
+		BUG_ON(clk_info->parents[0] == -1);
+		clk_init.num_parents = 1;
+		parent = cgu->clocks.clks[clk_info->parents[0]];
+		parent_names[0] = __clk_get_name(parent);
+	}
+
+	if (caps & CGU_CLK_CUSTOM) {
+		clk_init.ops = clk_info->custom.clk_ops;
+
+		caps &= ~CGU_CLK_CUSTOM;
+
+		if (caps) {
+			pr_err("%s: custom clock may not be combined with type 0x%x\n",
+			       __func__, caps);
+			goto out;
+		}
+	} else if (caps & CGU_CLK_PLL) {
+		clk_init.ops = &jz47xx_pll_ops;
+
+		caps &= ~CGU_CLK_PLL;
+
+		if (caps) {
+			pr_err("%s: PLL may not be combined with type 0x%x\n",
+			       __func__, caps);
+			goto out;
+		}
+	} else {
+		clk_init.ops = &jz47xx_clk_ops;
+	}
+
+	/* nothing to do for gates */
+	caps &= ~CGU_CLK_GATE;
+
+	if (caps & CGU_CLK_MUX) {
+		if (!(caps & CGU_CLK_MUX_GLITCHFREE))
+			clk_init.flags |= CLK_SET_PARENT_GATE;
+
+		caps &= ~(CGU_CLK_MUX | CGU_CLK_MUX_GLITCHFREE);
+	}
+
+	if (caps & CGU_CLK_DIV) {
+		caps &= ~CGU_CLK_DIV;
+	} else {
+		/* pass rate changes to the parent clock */
+		clk_init.flags |= CLK_SET_RATE_PARENT;
+	}
+
+	if (caps) {
+		pr_err("%s: unknown clock type 0x%x\n", __func__, caps);
+		goto out;
+	}
+
+	clk = clk_register(NULL, &jz_clk->hw);
+	if (IS_ERR(clk)) {
+		pr_err("%s: failed to register clock '%s'\n", __func__,
+		       clk_info->name);
+		err = PTR_ERR(clk);
+		goto out;
+	}
+
+	err = clk_register_clkdev(clk, clk_info->name, NULL);
+	if (err)
+		goto out;
+
+	cgu->clocks.clks[idx] = clk;
+out:
+	if (err)
+		kfree(jz_clk);
+	return err;
+}
+
+struct jz47xx_cgu *jz47xx_cgu_new(const struct jz47xx_cgu_clk_info *clock_info,
+				  unsigned num_clocks,
+				  struct device_node *np)
+{
+	struct jz47xx_cgu *cgu;
+
+	cgu = kzalloc(sizeof(*cgu), GFP_KERNEL);
+	if (!cgu) {
+		pr_err("%s: failed to allocate struct jz47xx_cgu\n", __func__);
+		goto err_out;
+	}
+
+	cgu->base = of_iomap(np, 0);
+	if (!cgu->base) {
+		pr_err("%s: failed to map CGU registers\n", __func__);
+		goto err_out_free;
+	}
+
+	cgu->np = np;
+	cgu->clock_info = clock_info;
+	cgu->clocks.clk_num = num_clocks;
+
+	return cgu;
+
+err_out_free:
+	kfree(cgu);
+err_out:
+	return NULL;
+}
+
+int jz47xx_cgu_register_clocks(struct jz47xx_cgu *cgu)
+{
+	unsigned i;
+	int err = -EINVAL;
+
+	spin_lock_init(&cgu->divmux_lock);
+	spin_lock_init(&cgu->power_lock);
+
+	cgu->clocks.clks = kzalloc(sizeof(struct clk *) * cgu->clocks.clk_num,
+				   GFP_KERNEL);
+	if (!cgu->clocks.clks) {
+		pr_err("%s: failed to alloc clock table\n", __func__);
+		goto err_out;
+	}
+
+	for (i = 0; i < cgu->clocks.clk_num; i++) {
+		err = register_clock(cgu, i);
+		if (err)
+			goto err_out_unregister;
+	}
+
+	err = of_clk_add_provider(cgu->np, of_clk_src_onecell_get,
+				  &cgu->clocks);
+	if (err)
+		goto err_out_unregister;
+
+	return 0;
+err_out_unregister:
+	if (cgu) {
+		for (i = 0; i < cgu->clocks.clk_num; i++) {
+			if (!cgu->clocks.clks[i])
+				continue;
+			if (cgu->clock_info[i].type & CGU_CLK_EXT)
+				clk_put(cgu->clocks.clks[i]);
+			else
+				clk_unregister(cgu->clocks.clks[i]);
+		}
+		kfree(cgu->clocks.clks);
+	}
+err_out:
+	return err;
+}
diff -urN a/drivers/clk/jz47xx/jz47xx-cgu.h b/drivers/clk/jz47xx/jz47xx-cgu.h
--- a/drivers/clk/jz47xx/jz47xx-cgu.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/clk/jz47xx/jz47xx-cgu.h	2014-11-18 21:55:27.939253958 +0100
@@ -0,0 +1,208 @@
+/*
+ * JZ47xx SoC CGU driver
+ *
+ * Copyright (c) 2013 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DRIVERS_CLK_JZ47XX_JZ47XX_CGU_H__
+#define __DRIVERS_CLK_JZ47XX_JZ47XX_CGU_H__
+
+#include <linux/of.h>
+#include <linux/spinlock.h>
+
+/**
+ * struct jz47xx_cgu_pll_cfg - describes the configuration of a PLL
+ * @m: the PLL multiplier
+ * @n: the PLL divider
+ * @od: the PLL post-VCO divider
+ * @bypass: 1 to bypass the PLL (output its input), else 0
+ * @enable: 1 to enable the PLL, else 0
+ */
+struct jz47xx_cgu_pll_cfg {
+	unsigned m;
+	unsigned n;
+	unsigned od;
+	unsigned bypass:1;
+	unsigned enable:1;
+};
+
+/**
+ * struct jz47xx_cgu_pll_info - information about a PLL
+ * @max_m: maximum PLL multiplier
+ * @max_n: maximum PLL divider
+ * @max_od: maximum PLL post-VCO divider
+ * @reg: the offset of the PLL's control register within the CGU
+ * @get_cfg: get the current PLL configuration
+ * @set_cfg: set the current PLL configuration
+ */
+struct jz47xx_cgu_pll_info {
+	unsigned max_m;
+	unsigned max_n;
+	unsigned max_od;
+
+	unsigned reg;
+
+	void (*get_cfg)(void __iomem *reg,
+			struct jz47xx_cgu_pll_cfg *setup);
+	int (*set_cfg)(void __iomem *reg,
+		       const struct jz47xx_cgu_pll_cfg *setup);
+};
+
+/**
+ * struct jz47xx_cgu_mux_info - information about a clock mux
+ * @reg: offset of the mux control register within the CGU
+ * @shift: number of bits to shift the mux value by (ie. the index of
+ *         the lowest bit of the mux value within its control register)
+ * @bits: the size of the mux value in bits
+ */
+struct jz47xx_cgu_mux_info {
+	unsigned reg;
+	unsigned shift:5;
+	unsigned bits:5;
+};
+
+/**
+ * struct jz47xx_cgu_div_info - information about a divider
+ * @reg: offset of the divider control register within the CGU
+ * @shift: number of bits to shift the divide value by (ie. the index of
+ *         the lowest bit of the divide value within its control register)
+ * @bits: the size of the divide value in bits
+ * @ce_bit: the index of the change enable bit within reg, or -1 is there
+ *          isn't one
+ * @busy_bit: the index of the busy bit within reg, or -1 is there isn't one
+ * @stop_bit: the index of the stop bit within reg, or -1 is there isn't one
+ */
+struct jz47xx_cgu_div_info {
+	unsigned reg;
+	unsigned shift:5;
+	unsigned bits:5;
+	int ce_bit:6;
+	int busy_bit:6;
+	int stop_bit:6;
+};
+
+/**
+ * struct jz47xx_cgu_custom_info - information about a custom (SoC) clock
+ */
+struct jz47xx_cgu_custom_info {
+	struct clk_ops *clk_ops;
+};
+
+/**
+ * struct jz47xx_cgu_clk_info - information about a clock
+ * @name: name of the clock
+ * @type: a bitmask formed from CGU_CLK_* values
+ * @parents: an array of the indices of potential parents of this clock
+ *           within the clock_info array of the CGU, or -1 in entries
+ *           which correspond to no valid parent
+ * @pll: information valid if type includes CGU_CLK_PLL
+ * @gate_bit: the index of the gate bit in the CLKGR* registers, valid if
+ *            type includes CGU_CLK_GATE
+ * @mux: information valid if type includes CGU_CLK_MUX
+ * @div: information valid if type includes CGU_CLK_DIV
+ */
+struct jz47xx_cgu_clk_info {
+	const char *name;
+
+	enum {
+		CGU_CLK_NONE		= 0,
+		CGU_CLK_EXT		= (1 << 0),
+		CGU_CLK_PLL		= (1 << 1),
+		CGU_CLK_GATE		= (1 << 2),
+		CGU_CLK_MUX		= (1 << 3),
+		CGU_CLK_MUX_GLITCHFREE	= (1 << 4),
+		CGU_CLK_DIV		= (1 << 5),
+		CGU_CLK_CUSTOM		= (1 << 6),
+	} type;
+
+	int parents[4];
+
+	union {
+		struct jz47xx_cgu_pll_info pll;
+
+		struct {
+			unsigned gate_bit;
+			struct jz47xx_cgu_mux_info mux;
+			struct jz47xx_cgu_div_info div;
+		};
+
+		struct jz47xx_cgu_custom_info custom;
+	};
+};
+
+/**
+ * struct jz47xx_cgu - data about the CGU
+ * @np: the device tree node that caused the CGU to be probed
+ * @base: the ioremap'ed base address of the CGU registers
+ * @clock_info: an array containing information about implemented clocks
+ * @clocks: used to provide clocks to DT, allows lookup of struct clk*
+ * @gate_lock: lock to be held whilst (un)gating a clock
+ * @divmux_lock: lock to be held whilst re-muxing of rate-changing a clock
+ */
+struct jz47xx_cgu {
+	struct device_node *np;
+	void __iomem *base;
+
+	const struct jz47xx_cgu_clk_info *clock_info;
+	struct clk_onecell_data clocks;
+
+	spinlock_t divmux_lock;		/* must be held when changing a divide
+					   or re-muxing a clock */
+	spinlock_t power_lock;		/* must be held when changing a power
+					   manager register */
+};
+
+/**
+ * struct jz47xx_clk - private data for a clock
+ * @hw: see Documentation/clk.txt
+ * @cgu: a pointer to the CGU data
+ * @idx: the index of this clock in cgu->clock_info
+ */
+struct jz47xx_clk {
+	struct clk_hw hw;
+	struct jz47xx_cgu *cgu;
+	unsigned idx;
+};
+
+#define to_jz47xx_clk(_hw) container_of(_hw, struct jz47xx_clk, hw)
+
+/**
+ * jz47xx_cgu_new - create a new CGU instance
+ * @clock_info: an array of clock information structures describing the clocks
+ *              which are implemented by the CGU
+ * @num_clocks: the number of entries in clock_info
+ * @np: the device tree node which causes this CGU to be probed
+ *
+ * Returns an opaque pointer to the CGU instance if initialisation & clock
+ * registration is successful, otherwise NULL.
+ */
+struct jz47xx_cgu *jz47xx_cgu_new(const struct jz47xx_cgu_clk_info *clock_info,
+				  unsigned num_clocks,
+				  struct device_node *np);
+
+/**
+ * jz47xx_cgu_register_clocks - Registers the clocks
+ * @cgu: pointer to cgu data
+ *
+ * Returns 1 on success and -EINVAL if unsuccesful.
+ */
+int jz47xx_cgu_register_clocks(struct jz47xx_cgu *cgu);
+
+#endif /* __DRIVERS_CLK_JZ47XX_JZ47XX_CGU_H__ */
+
diff -urN a/drivers/clk/jz47xx/Makefile b/drivers/clk/jz47xx/Makefile
--- a/drivers/clk/jz47xx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/clk/jz47xx/Makefile	2014-11-18 21:56:22.983443690 +0100
@@ -0,0 +1,2 @@
+obj-y				+= jz47xx-cgu.o
+obj-$(CONFIG_MACH_JZ4780)	+= jz4780-cgu.o
diff -urN a/drivers/clk/Makefile b/drivers/clk/Makefile
--- a/drivers/clk/Makefile	2014-11-09 23:55:29.000000000 +0100
+++ b/drivers/clk/Makefile	2014-11-18 21:51:54.866512287 +0100
@@ -46,6 +46,7 @@
 obj-$(CONFIG_ARCH_HI3xxx)		+= hisilicon/
 obj-$(CONFIG_ARCH_HIP04)		+= hisilicon/
 obj-$(CONFIG_ARCH_HIX5HD2)		+= hisilicon/
+obj-$(CONFIG_MACH_JZ4780)		+= jz47xx/ # JZ47xx CGU clocks
 obj-$(CONFIG_COMMON_CLK_KEYSTONE)	+= keystone/
 ifeq ($(CONFIG_COMMON_CLK), y)
 obj-$(CONFIG_ARCH_MMP)			+= mmp/
diff -urN a/include/dt-bindings/clock/jz4780-cgu.h b/include/dt-bindings/clock/jz4780-cgu.h
--- a/include/dt-bindings/clock/jz4780-cgu.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/dt-bindings/clock/jz4780-cgu.h	2014-11-18 21:59:22.640057802 +0100
@@ -0,0 +1,89 @@
+/*
+ * This header provides clock numbers for the ingenic,jz4780-cgu DT binding.
+ *
+ * They are roughly ordered as:
+ *   - external clocks
+ *   - PLLs
+ *   - muxes/dividers in the order they appear in the jz4780 programmers manual
+ *   - gates in order of their bit in the CLKGR* registers
+ */
+
+#ifndef __DT_BINDINGS_CLOCK_JZ4780_CGU_H__
+#define __DT_BINDINGS_CLOCK_JZ4780_CGU_H__
+
+#define JZ4780_CLK_EXCLK	0
+#define JZ4780_CLK_RTCLK	1
+#define JZ4780_CLK_APLL		2
+#define JZ4780_CLK_MPLL		3
+#define JZ4780_CLK_EPLL		4
+#define JZ4780_CLK_VPLL		5
+#define JZ4780_CLK_OTGPHY	6
+#define JZ4780_CLK_SCLKA	7
+#define JZ4780_CLK_CPUMUX	8
+#define JZ4780_CLK_CPU		9
+#define JZ4780_CLK_L2CACHE	10
+#define JZ4780_CLK_AHB0		11
+#define JZ4780_CLK_AHB2PMUX	12
+#define JZ4780_CLK_AHB2		13
+#define JZ4780_CLK_PCLK		14
+#define JZ4780_CLK_DDR		15
+#define JZ4780_CLK_VPU		16
+#define JZ4780_CLK_I2SPLL	17
+#define JZ4780_CLK_I2S		18
+#define JZ4780_CLK_LCD0PIXCLK	19
+#define JZ4780_CLK_LCD1PIXCLK	20
+#define JZ4780_CLK_MSCMUX	21
+#define JZ4780_CLK_MSC0		22
+#define JZ4780_CLK_MSC1		23
+#define JZ4780_CLK_MSC2		24
+#define JZ4780_CLK_UHC		25
+#define JZ4780_CLK_SSIPLL	26
+#define JZ4780_CLK_SSI		27
+#define JZ4780_CLK_CIMMCLK	28
+#define JZ4780_CLK_PCMPLL	29
+#define JZ4780_CLK_PCM		30
+#define JZ4780_CLK_GPU		31
+#define JZ4780_CLK_HDMI		32
+#define JZ4780_CLK_BCH		33
+#define JZ4780_CLK_NEMC		34
+#define JZ4780_CLK_OTG0		35
+#define JZ4780_CLK_SSI0		36
+#define JZ4780_CLK_SMB0		37
+#define JZ4780_CLK_SMB1		38
+#define JZ4780_CLK_SCC		39
+#define JZ4780_CLK_AIC		40
+#define JZ4780_CLK_TSSI0	41
+#define JZ4780_CLK_OWI		42
+#define JZ4780_CLK_KBC		43
+#define JZ4780_CLK_SADC		44
+#define JZ4780_CLK_UART0	45
+#define JZ4780_CLK_UART1	46
+#define JZ4780_CLK_UART2	47
+#define JZ4780_CLK_UART3	48
+#define JZ4780_CLK_SSI1		49
+#define JZ4780_CLK_SSI2		50
+#define JZ4780_CLK_PDMA		51
+#define JZ4780_CLK_GPS		52
+#define JZ4780_CLK_MAC		53
+#define JZ4780_CLK_SMB2		54
+#define JZ4780_CLK_CIM		55
+#define JZ4780_CLK_LCD		56
+#define JZ4780_CLK_TVE		57
+#define JZ4780_CLK_IPU		58
+#define JZ4780_CLK_DDR0		59
+#define JZ4780_CLK_DDR1		60
+#define JZ4780_CLK_SMB3		61
+#define JZ4780_CLK_TSSI1	62
+#define JZ4780_CLK_COMPRESS	63
+#define JZ4780_CLK_AIC1		64
+#define JZ4780_CLK_GPVLC	65
+#define JZ4780_CLK_OTG1		66
+#define JZ4780_CLK_UART4	67
+#define JZ4780_CLK_AHBMON	68
+#define JZ4780_CLK_SMB4		69
+#define JZ4780_CLK_DES		70
+#define JZ4780_CLK_X2D		71
+#define JZ4780_CLK_CORE1	72
+
+#endif /* __DT_BINDINGS_CLOCK_JZ4780_CGU_H__ */
+
